package carousel

import (
	"fmt"
	"github.com/axzilla/templui/icon"
	"github.com/axzilla/templui/util"
	"strconv"
)

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Autoplay   bool
	Interval   int
	Loop       bool
}

type ContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ItemProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type PreviousProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type NextProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type IndicatorsProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Count      int
}

templ Carousel(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"carousel-component relative overflow-hidden w-full",
				p.Class,
			),
		}
		data-autoplay={ strconv.FormatBool(p.Autoplay) }
		data-interval={ fmt.Sprintf("%d", func() int {
            if p.Interval == 0 {
                return 5000
            }
            return p.Interval
        }()) }
		data-loop={ strconv.FormatBool(p.Loop) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"carousel-track flex h-full w-full transition-transform duration-500 ease-in-out",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Item(props ...ItemProps) {
	{{ var p ItemProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"carousel-item flex-shrink-0 w-full h-full relative",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Previous(props ...PreviousProps) {
	{{ var p PreviousProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<button
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"carousel-prev absolute left-2 top-1/2 transform -translate-y-1/2 p-2 rounded-full bg-black/20 text-white hover:bg-black/40 focus:outline-none",
				p.Class,
			),
		}
		aria-label="Previous slide"
		type="button"
		{ p.Attributes... }
	>
		@icon.ChevronLeft()
	</button>
}

templ Next(props ...NextProps) {
	{{ var p NextProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<button
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"carousel-next absolute right-2 top-1/2 transform -translate-y-1/2 p-2 rounded-full bg-black/20 text-white hover:bg-black/40 focus:outline-none",
				p.Class,
			),
		}
		aria-label="Next slide"
		type="button"
		{ p.Attributes... }
	>
		@icon.ChevronRight()
	</button>
}

templ Indicators(props ...IndicatorsProps) {
	{{ var p IndicatorsProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"absolute bottom-4 left-1/2 transform -translate-x-1/2 flex gap-2",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		for i := 0; i < p.Count; i++ {
			<button
				class={
					util.TwMerge(
						"carousel-indicator w-3 h-3 rounded-full bg-white/50 hover:bg-white/80 focus:outline-none transition-colors",
						util.If(i == 0, "bg-white"),
					),
				}
				aria-label={ fmt.Sprintf("Go to slide %d", i+1) }
				type="button"
			></button>
		}
	</div>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
            function initCarousel(carouselEl) {
                // Prevent double initialization and handle null element
                if (!carouselEl || carouselEl.dataset.carouselInitialized) {
                    return;
                }
                carouselEl.dataset.carouselInitialized = 'true';

                const state = {
                    currentIndex: 0,
                    slideCount: 0,
                    autoplay: carouselEl.dataset.autoplay === 'true',
                    interval: parseInt(carouselEl.dataset.interval || 5000),
                    loop: carouselEl.dataset.loop === 'true',
                    autoplayInterval: null,
                    isHovering: false,
                    touchStartX: 0
                };

                const track = carouselEl.querySelector('.carousel-track');
                const items = Array.from(track ? track.querySelectorAll('.carousel-item') : []);
                const indicators = Array.from(carouselEl.querySelectorAll('.carousel-indicator'));
                const prevBtn = carouselEl.querySelector('.carousel-prev');
                const nextBtn = carouselEl.querySelector('.carousel-next');

                // Abort if no items found
                if (items.length === 0) {
                    delete carouselEl.dataset.carouselInitialized; // Clean up flag if we abort
                    return;
                }
                state.slideCount = items.length;

                // Warn if indicator count doesn't match item count (but continue)
                if (indicators.length > 0 && indicators.length !== state.slideCount) {
                     console.warn(`Indicator count (${indicators.length}) does not match slide count (${state.slideCount}) for carousel:`, carouselEl.id || 'no-id');
                }

                function updateTrackPosition() {
                    if (track) {
                        track.style.transform = `translateX(-${state.currentIndex * 100}%)`;
                    }
                }

                function updateIndicators() {
                    indicators.forEach((indicator, i) => {
                        // Only update indicators corresponding to actual items
                        if (i < state.slideCount) {
                            if (i === state.currentIndex) {
                                indicator.classList.add('bg-white');
                                indicator.classList.remove('bg-white/50');
                            } else {
                                indicator.classList.remove('bg-white');
                                indicator.classList.add('bg-white/50');
                            }
                             indicator.style.display = ''; // Ensure visible
                        } else {
                            // Hide indicators that don't have a corresponding item
                            indicator.style.display = 'none';
                        }
                    });
                }

                function updateButtons() {
                    // Disable previous button if not looping and at the first slide
                    if (prevBtn) {
                        prevBtn.disabled = !state.loop && state.currentIndex === 0;
                        if (prevBtn.disabled) {
                            prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        }
                    }
                     // Disable next button if not looping and at the last slide
                    if (nextBtn) {
                        nextBtn.disabled = !state.loop && state.currentIndex === state.slideCount - 1;
                        if (nextBtn.disabled) {
                            nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        }
                    }
                }

                function startAutoplay() {
                    // Clear existing interval if any
                    if (state.autoplayInterval) {
                        clearInterval(state.autoplayInterval);
                    }
                    // Start new interval only if autoplay is enabled
                    if (state.autoplay) {
                         state.autoplayInterval = setInterval(() => {
                            // Only advance if not hovering
                            if (!state.isHovering) {
                                goToNext();
                            }
                        }, state.interval);
                    }
                }

                function stopAutoplay() {
                    if (state.autoplayInterval) {
                        clearInterval(state.autoplayInterval);
                        state.autoplayInterval = null;
                    }
                }

                function goToNext() {
                    let nextIndex = state.currentIndex + 1;
                    if (nextIndex >= state.slideCount) {
                        if (state.loop) {
                            nextIndex = 0; // Loop back to start
                        } else {
                            return; // Stop at the end if not looping
                        }
                    }
                    goToSlide(nextIndex);
                }

                function goToPrev() {
                    let prevIndex = state.currentIndex - 1;
                    if (prevIndex < 0) {
                        if (state.loop) {
                            prevIndex = state.slideCount - 1; // Loop back to end
                        } else {
                            return; // Stop at the beginning if not looping
                        }
                    }
                    goToSlide(prevIndex);
                }

                function goToSlide(index) {
                     // Add bounds check and handle looping/clamping
                    if (index < 0 || index >= state.slideCount) {
                        if (state.loop) {
                            index = (index + state.slideCount) % state.slideCount;
                        } else {
                             // Don't move if index is out of bounds and not looping
                            return;
                        }
                    }
                    // No change if already on the target slide
                    if (index === state.currentIndex) return;

                    state.currentIndex = index;
                    updateTrackPosition();
                    updateIndicators();
                    updateButtons();

                    // Restart autoplay timer after manual navigation if enabled
                    if (state.autoplay) {
                        stopAutoplay();
                        if (!state.isHovering) { // Don't restart if currently hovering
                            startAutoplay();
                        }
                    }
                }

                function handleTouchStart(event) {
                    // Only use the first touch point
                    state.touchStartX = event.touches[0].clientX;
                }

                function handleTouchEnd(event) {
                    // Only use the first changed touch point
                    const touchEndX = event.changedTouches[0].clientX;
                    const diff = state.touchStartX - touchEndX;
                    const sensitivity = 50; // Minimum swipe distance

                    // Check if swipe distance is significant
                    if (Math.abs(diff) > sensitivity) {
                        if (diff > 0) { // Swiped left (Next)
                            goToNext();
                        } else { // Swiped right (Previous)
                            goToPrev();
                        }
                    }
                }

                // --- Attach Event Listeners ---

                if (track) {
                    // Use passive listeners for touch events for better scroll performance
                    track.addEventListener('touchstart', handleTouchStart, { passive: true });
                    track.addEventListener('touchend', handleTouchEnd, { passive: true });
                }

                indicators.forEach((indicator, index) => {
                    // Only add listeners for indicators corresponding to items
                     if (index < state.slideCount) {
                        indicator.addEventListener('click', () => goToSlide(index));
                     }
                });

                if (prevBtn) {
                    prevBtn.addEventListener('click', goToPrev);
                }

                if (nextBtn) {
                    nextBtn.addEventListener('click', goToNext);
                }

                // Pause autoplay on hover
                carouselEl.addEventListener('mouseenter', () => {
                    state.isHovering = true;
                    if (state.autoplay) {
                        stopAutoplay();
                    }
                });

                // Resume autoplay on mouse leave
                carouselEl.addEventListener('mouseleave', () => {
                    state.isHovering = false;
                    if (state.autoplay) {
                         // Restart autoplay only if it was running and mouse leaves
                        startAutoplay();
                    }
                });

                // --- Initial State Setup ---
                updateTrackPosition();
                updateIndicators();
                updateButtons();

                // Start autoplay if enabled
                if (state.autoplay) {
                    startAutoplay();
                }
            }

            // --- Initialization Logic ---

            function initializeAllCarousels() {
                document.querySelectorAll('.carousel-component:not([data-carousel-initialized])').forEach(initCarousel);
            }

            // Initial page load: Wait for DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeAllCarousels);
            } else {
                // DOM is already ready, run initialization now
                initializeAllCarousels();
            }

            // HTMX integration: Initialize carousels loaded via htmx:afterSwap
            document.body.addEventListener('htmx:afterSwap', function(event) {
                const targetElement = event.target;

                // Check if the swapped element itself is an uninitialized carousel
                if (targetElement instanceof Element && targetElement.matches && targetElement.matches('.carousel-component:not([data-carousel-initialized])')) {
                    initCarousel(targetElement);
                }

                // Check for any uninitialized carousels within the swapped element
                if (targetElement instanceof Element && targetElement.querySelectorAll) {
                    const nestedCarousels = targetElement.querySelectorAll('.carousel-component:not([data-carousel-initialized])');
                    if (nestedCarousels.length > 0) {
                        nestedCarousels.forEach(initCarousel);
                    }
                }
            });
		</script>
	}
}
