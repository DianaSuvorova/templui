package dropdown

import "github.com/axzilla/templui/util"

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type TriggerProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Width      string
	MaxHeight  string
	Align      string
	Side       string
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type LabelProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ItemProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Disabled   bool
	Href       string
	Target     string
}

type SeparatorProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ShortcutProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubTriggerProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SubContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type PortalProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

templ Dropdown(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	<div
		id={ p.ID }
		data-dropdown
		class={ util.TwMerge("relative inline-block text-left", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Trigger(props ...TriggerProps) {
	{{ var p TriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-trigger
		class={ util.TwMerge("inline-block", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	{{
		var maxHeight string = "300px"
		if p.MaxHeight != "" {
			maxHeight = p.MaxHeight
		}
	}}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-content
		class={ util.TwMerge(
				"absolute z-50 rounded-md bg-popover p-1 shadow-md focus:outline-none overflow-auto",
				"border border-border",
				"min-w-[8rem]",
				p.Width,
				p.Class,
		) }
		style={ "display: none; top: 100%; margin-top: 0.25rem; left: 0; max-height: " + maxHeight + ";" }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("py-1", p.Class) }
		role="group"
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Label(props ...LabelProps) {
	{{ var p LabelProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("px-2 py-1.5 text-sm font-semibold", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Item(props ...ItemProps) {
	{{ var p ItemProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	if p.Href != "" {
		<a
			id={ p.ID }
			if p.Href != "" {
				href={ templ.SafeURL(p.Href) }
			}
			if p.Target != "" {
				target={ p.Target }
			}
			class={
				util.TwMerge(
					"flex text-left items-center px-2 py-1.5 text-sm rounded-sm",
					util.If(!p.Disabled, "focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default"),
					util.If(p.Disabled, "opacity-50 pointer-events-none"),
					p.Class,
				),
			}
			role="menuitem"
			data-dropdown-item
			{ p.Attributes... }
		>
			{ children... }
		</a>
	} else {
		<button
			id={ p.ID }
			class={
				util.TwMerge(
					"w-full text-left flex items-center justify-between px-2 py-1.5 text-sm rounded-sm",
					util.If(!p.Disabled, "focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default"),
					util.If(p.Disabled, "opacity-50 pointer-events-none"),
					p.Class,
				),
			}
			role="menuitem"
			data-dropdown-item
			disabled?={ p.Disabled }
			{ p.Attributes... }
		>
			{ children... }
		</button>
	}
}

templ Separator(props ...SeparatorProps) {
	{{ var p SeparatorProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("h-px my-1 -mx-1 bg-muted", p.Class) }
		role="separator"
		{ p.Attributes... }
	></div>
}

templ Shortcut(props ...ShortcutProps) {
	{{ var p ShortcutProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("ml-auto text-xs tracking-widest opacity-60", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</span>
}

templ Sub(props ...SubProps) {
	{{ var p SubProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-submenu
		class={ util.TwMerge("relative", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ SubTrigger(props ...SubTriggerProps) {
	{{ var p SubTriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<button
		if p.ID != "" {
			id={ p.ID }
		}
		type="button"
		data-dropdown-submenu-trigger
		class={
			util.TwMerge(
				"w-full text-left flex items-center justify-between px-2 py-1.5 text-sm rounded-sm",
				"focus:bg-accent focus:text-accent-foreground hover:bg-accent hover:text-accent-foreground cursor-default",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		<span>
			{ children... }
		</span>
		<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-auto">
			<path d="M6.5 3L11.5 8L6.5 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
		</svg>
	</button>
}

templ SubContent(props ...SubContentProps) {
	{{ var p SubContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-dropdown-submenu-content
		class={ util.TwMerge(
			"absolute z-[9999] min-w-[8rem] rounded-md border bg-popover p-1 shadow-lg",
				p.Class,
		) }
		style="display: none; top: 0; left: 100%; margin-left: 0.25rem;"
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

var dropdownHandle = templ.NewOnceHandle()

templ Script() {
	@dropdownHandle.Once() {
		<script nonce={ templ.GetNonce(ctx) }>
			// Use window scope and check for existence to prevent duplicate declarations
			if (typeof window.activeDropdowns === 'undefined') {
				window.activeDropdowns = new Map(); // Track state: dropdownRoot -> { isOpen: bool, closeMenu: func, closeSubmenus: func, resizeListener: func|null, clickAwayListener: func|null, escListener: func|null }
			}
			if (typeof window.activeSubmenus === 'undefined') {
				window.activeSubmenus = new Map(); // Track state: submenuRoot -> { isOpen: bool, closeTimer: number|null, trigger: element, content: element }
			}

			// --- Core Logic Functions ---

			// Renamed: Only used for fixed-position submenus now
			function positionSubmenuElement(trigger, panel, placement = 'right') { 
				// This logic remains largely the same, using position: fixed
				if (!trigger || !panel) return;
				panel.style.display = 'block'; 
				const triggerRect = trigger.getBoundingClientRect();
				const panelRect = panel.getBoundingClientRect();
				const vw = window.innerWidth;
				const vh = window.innerHeight;
				let top = triggerRect.top; // Default align top for right placement
				let left = triggerRect.right + 4;
				if (placement === 'right') {
					if (left + panelRect.width > vw) { left = triggerRect.left - panelRect.width - 4; }
					if (top + panelRect.height > vh) { // Adjust top if overflows bottom
						top = vh - panelRect.height - 10;
					}
				} else {
					// Maybe add logic for other submenu placements if needed
					// For now, assume 'right'
				}
				top = Math.max(10, top);
				left = Math.max(10, left);
				panel.style.position = 'fixed'; 
				panel.style.top = `${top}px`;
				panel.style.left = `${left}px`;
			}

			function closeAllDropdowns() {
				window.activeDropdowns.forEach(state => state.closeMenu());
			}

			// --- Setup Functions ---

			function setupDropdown(dropdownRoot) {
				if (window.activeDropdowns.has(dropdownRoot)) return;

				const trigger = dropdownRoot.querySelector('[data-dropdown-trigger]');
				const content = dropdownRoot.querySelector('[data-dropdown-content]');
				if (!trigger || !content) return;

				const state = {
					isOpen: false,
					// Removed resizeListener
					clickAwayListener: null,
					escListener: null,
				};

				const closeSubmenus = () => {
					dropdownRoot.querySelectorAll('[data-dropdown-submenu]').forEach(submenuEl => {
						const subState = window.activeSubmenus.get(submenuEl);
						if (subState && subState.isOpen) {
							clearTimeout(subState.closeTimer);
							subState.content.style.display = 'none';
							subState.isOpen = false;
						}
					});
				};
				state.closeSubmenus = closeSubmenus;

				const closeMenu = () => {
					if (!state.isOpen) return;
					state.isOpen = false;
					content.style.display = 'none';
					closeSubmenus();
					// Remove resizeListener handling
					if (state.clickAwayListener) document.removeEventListener('click', state.clickAwayListener);
					if (state.escListener) document.removeEventListener('keydown', state.escListener);
					// state.resizeListener = null; // Removed
					state.clickAwayListener = null;
					state.escListener = null;
					window.activeDropdowns.delete(dropdownRoot);
				};
				state.closeMenu = closeMenu;

				const openMenu = () => {
					if (state.isOpen) return;
					closeAllDropdowns(); 
					state.isOpen = true;
					content.style.display = 'block';
					// No JS positioning call for main content anymore

					// Removed resizeListener setup
					state.clickAwayListener = (event) => {
						if (!dropdownRoot.contains(event.target)) {
							closeMenu();
						}
					};
					state.escListener = (event) => {
						if (event.key === 'Escape') {
							closeMenu();
						}
					};

					// window.addEventListener('resize', state.resizeListener); // Removed
					setTimeout(() => document.addEventListener('click', state.clickAwayListener), 0);
					document.addEventListener('keydown', state.escListener);
					window.activeDropdowns.set(dropdownRoot, state);
				};

				trigger.addEventListener('click', (event) => {
					event.stopPropagation(); // Prevent triggering clickAwayListener immediately
					if (state.isOpen) {
						closeMenu();
					} else {
						openMenu();
					}
				});

				// Setup submenus within this dropdown
				dropdownRoot.querySelectorAll('[data-dropdown-submenu]').forEach(setupSubmenu);
			}

			function setupSubmenu(submenuRoot) {
				if (window.activeSubmenus.has(submenuRoot)) return;

				const trigger = submenuRoot.querySelector('[data-dropdown-submenu-trigger]');
				const content = submenuRoot.querySelector('[data-dropdown-submenu-content]');
				if (!trigger || !content) return;

				const state = {
					isOpen: false,
					closeTimer: null,
					trigger: trigger,
					content: content,
				};

				const openSubmenu = () => {
					clearTimeout(state.closeTimer);
					if (state.isOpen) return;
					state.isOpen = true;
					document.body.appendChild(content);
					content.style.display = 'block';
					positionSubmenuElement(trigger, content, 'right');
				};

				const startCloseTimer = () => {
					clearTimeout(state.closeTimer);
					state.closeTimer = setTimeout(() => {
						if (state.isOpen) {
							content.style.display = 'none';
							state.isOpen = false;
							// Consider moving content back if needed, or leave it on body?
						}
					}, 200); // Delay before closing
				};

				trigger.addEventListener('mouseenter', openSubmenu);
				trigger.addEventListener('focus', openSubmenu);
				trigger.addEventListener('mouseleave', startCloseTimer);
				trigger.addEventListener('blur', startCloseTimer);

				content.addEventListener('mouseenter', () => clearTimeout(state.closeTimer));
				content.addEventListener('mouseleave', startCloseTimer);
				
				window.activeSubmenus.set(submenuRoot, state);
			}

			// --- Global Click Handler for Items ---
			document.addEventListener('click', (event) => {
				const item = event.target.closest('[data-dropdown-item]');
				if (!item) return;

				const dropdownRoot = item.closest('[data-dropdown]');
				if (dropdownRoot) {
					const state = window.activeDropdowns.get(dropdownRoot);
					if (state && state.closeMenu) {
						state.closeMenu(); // Close the parent dropdown
					}
				}
				// No stopPropagation needed here, clickAway listener handles it
			});

			// --- HTMX Integration ---
			document.body.addEventListener('htmx:afterSwap', (event) => {
				const target = event.detail.target || event.target;
				if (target?.querySelectorAll) {
					if (target.matches('[data-dropdown]')) setupDropdown(target);
					target.querySelectorAll('[data-dropdown]').forEach(setupDropdown);
				}
			});

			document.body.addEventListener('htmx:beforeSwap', (event) => {
				const target = event.detail.target || event.detail.elt;
				if (target?.querySelectorAll) {
					const cleanup = (el) => {
						if (el.matches('[data-dropdown]')) {
							const state = window.activeDropdowns.get(el);
							if (state?.closeMenu) state.closeMenu(); // Ensure cleanup removes listeners
							window.activeDropdowns.delete(el);
						}
						if (el.matches('[data-dropdown-submenu]')) {
							const subState = window.activeSubmenus.get(el);
							if (subState) {
								clearTimeout(subState.closeTimer);
								if (subState.content.parentNode === document.body) {
									document.body.removeChild(subState.content);
								}
								window.activeSubmenus.delete(el);
							}
						}
					};
					if (target.matches('[data-dropdown]') || target.matches('[data-dropdown-submenu]')) cleanup(target);
					target.querySelectorAll('[data-dropdown], [data-dropdown-submenu]').forEach(cleanup);
				}
			});

			// --- Init ---
			if (typeof window.initializeAllDropdowns === 'undefined') {
				window.initializeAllDropdowns = function() {
					document.querySelectorAll('[data-dropdown]').forEach(setupDropdown);
				};
			}
			
			// Run init when DOM is ready or immediately if already loaded
			if (document.readyState === 'complete' || document.readyState === 'interactive') {
				window.initializeAllDropdowns();
			} else {
				document.addEventListener('DOMContentLoaded', window.initializeAllDropdowns);
			}
</script>
	}
}
