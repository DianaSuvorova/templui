package inputotp

import (
	"github.com/axzilla/templui/util"
	"strconv"
)

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Value      string
	Required   bool
	Name       string
	HasError   bool
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SlotProps struct {
	ID          string
	Class       string
	Attributes  templ.Attributes
	Index       int
	Type        string
	Placeholder string
	Disabled    bool
}

type SeparatorProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

templ InputOTP(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID + "-container" }
		}
		if p.Value != "" {
			data-value={ p.Value }
		}
		class={
			util.TwMerge(
				"flex flex-row items-center gap-2 w-fit",
				p.Class,
			),
		}
		data-input-otp
		{ p.Attributes... }
	>
		<input
			type="hidden"
			if p.ID != "" {
				id={ p.ID }
			}
			if p.Name != "" {
				name={ p.Name }
			}
			data-input-otp-value-target
			required?={ p.Required }
		/>
		{ children... }
	</div>
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"flex gap-2",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Slot(props ...SlotProps) {
	{{ var p SlotProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Type == "" {
		{{ p.Type = "text" }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class="relative"
		{ p.Attributes... }
	>
		<input
			type={ p.Type }
			inputmode="numeric"
			if p.Placeholder != "" {
				placeholder={ p.Placeholder }
			}
			maxlength="1"
			class={
				util.TwMerge(
					"w-10 h-12 text-center",
					"rounded-md border border-input bg-background text-sm",
					"file:border-0 file:bg-transparent file:text-sm file:font-medium",
					"placeholder:text-muted-foreground",
					"focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
					"disabled:cursor-not-allowed disabled:opacity-50",
					p.Class,
				),
			}
			disabled?={ p.Disabled }
			data-input-index={ strconv.Itoa(p.Index) }
			data-input-otp-slot
		/>
	</div>
}

templ Separator(props ...SeparatorProps) {
	{{ var p SeparatorProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"flex items-center text-muted-foreground text-xl",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		<span>-</span>
	</div>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script nonce={ templ.GetNonce(ctx) }>
			// --- Input OTP Logic ---
			if (typeof window.inputOTPHandlerAttached === 'undefined') {
				window.inputOTPHandlerAttached = true;
				window._isProgrammaticFocus = false; // Initialize the flag

				const setupInputOTP = (container) => {
					const hiddenInput = container.querySelector('[data-input-otp-value-target]');
					const slots = Array.from(container.querySelectorAll('[data-input-otp-slot]')).sort((a, b) => {
						return parseInt(a.dataset.inputIndex) - parseInt(b.dataset.inputIndex);
					});

					if (!hiddenInput || slots.length === 0) return;

					const updateHiddenValue = () => {
						hiddenInput.value = slots.map(slot => slot.value).join('');
					};

					const findFirstEmptySlotIndex = () => {
						return slots.findIndex(slot => !slot.value);
					};

					const handleInput = (event) => {
						const input = event.target;
						const index = parseInt(input.dataset.inputIndex);

						// Prevent space character
						if (input.value === ' ') {
							input.value = '';
							return; // Stop further processing for space
						}

						if (input.value.length > 1) {
							input.value = input.value.slice(-1);
						}
						if (input.value && index < slots.length - 1) {
							slots[index + 1].focus();
						}
						updateHiddenValue();
					};

					const handleKeydown = (event) => {
						const input = event.target;
						const index = parseInt(input.dataset.inputIndex);

						if (event.key === 'Backspace') {
							const currentValue = input.value;
							if (index > 0) {
								event.preventDefault();
								window._isProgrammaticFocus = true; 
								if (currentValue) {
									input.value = '';
									updateHiddenValue();
									slots[index - 1].focus();
								} else {
									// If current was empty, clear previous and focus it
									slots[index - 1].value = ''; 
									updateHiddenValue(); // Update hidden value after clearing
									slots[index - 1].focus();
								}
								setTimeout(() => { window._isProgrammaticFocus = false; }, 0);
							}
							// Default backspace in first slot handled by browser
						}
						if (event.key === 'ArrowLeft' && index > 0) {
							event.preventDefault();
							window._isProgrammaticFocus = true; // Set flag
							slots[index - 1].focus();
							setTimeout(() => { window._isProgrammaticFocus = false; }, 0); // Reset flag
						}
						if (event.key === 'ArrowRight' && index < slots.length - 1) {
							event.preventDefault();
							window._isProgrammaticFocus = true; // Set flag
							slots[index + 1].focus();
							setTimeout(() => { window._isProgrammaticFocus = false; }, 0); // Reset flag
						}
					};

					const handlePaste = (event) => {
						event.preventDefault();

						// Get slots specific to THIS container
						const container = event.currentTarget;
						const slots = Array.from(container.querySelectorAll('[data-input-otp-slot]')).sort((a, b) => {
							return parseInt(a.dataset.inputIndex) - parseInt(b.dataset.inputIndex);
						});
						const hiddenInput = container.querySelector('[data-input-otp-value-target]');

						if (!hiddenInput || slots.length === 0) {
							console.error("InputOTP: Could not find elements for paste handling.");
							return;
						}

						const pastedData = (event.clipboardData || window.clipboardData).getData('text');
						const pastedChars = pastedData.replace(/\s/g, '').split('');

						let currentSlot = 0;
						for (let i = 0; i < pastedChars.length && currentSlot < slots.length; i++) {
							// if (slots[currentSlot].inputMode === 'numeric' && !/\d/.test(pastedChars[i])) continue;
							slots[currentSlot].value = pastedChars[i];
							currentSlot++;
						}

						let focusIndex = slots.findIndex(slot => !slot.value);
						if (focusIndex === -1) {
							focusIndex = slots.length - 1;
						}
						if (focusIndex >= 0 && focusIndex < slots.length) { // Check bounds
							slots[focusIndex].focus();
						}

						// Update the hidden value after pasting
						hiddenInput.value = slots.map(slot => slot.value).join('');
					};

					const handleFocus = (event) => {
						// If focus was triggered programmatically, ignore redirection
						if (window._isProgrammaticFocus) {
							window._isProgrammaticFocus = false; // Reset flag after use
							// Select text on programmatic focus too
							event.target.select();
							return;
						}
						
						// Existing logic for manual focus attempts
						const input = event.target;
						const index = parseInt(input.dataset.inputIndex);
						const firstEmptyIndex = findFirstEmptySlotIndex();

						if (firstEmptyIndex !== -1 && index !== firstEmptyIndex) {
							slots[firstEmptyIndex].focus();
							return;
						}

						input.select();
					};

					// Attach listeners to slots
					slots.forEach(slot => {
						slot.addEventListener('input', handleInput);
						slot.addEventListener('keydown', handleKeydown);
						slot.addEventListener('focus', handleFocus); // Add focus listener
					});

					// Attach paste listener to the container for delegation
					container.addEventListener('paste', handlePaste);

					// Initial value handling
					if (container.dataset.value) {
						const initialValue = container.dataset.value;
						slots.forEach((slot, index) => {
							if (index < initialValue.length) {
								slot.value = initialValue[index];
							}
						});
						updateHiddenValue();
					}

					// Label click handling
					const targetId = hiddenInput.id;
					if (targetId) {
						document.querySelectorAll(`label[for="${targetId}"]`).forEach(label => {
							// Avoid adding multiple listeners if setup is called again
							if (!label.dataset.inputOtpLabelListener) {
								label.addEventListener('click', (event) => {
									event.preventDefault();
									if (slots.length > 0) slots[0].focus();
								});
								label.dataset.inputOtpLabelListener = 'true';
							}
						});
					}

					// Store cleanup function reference if needed for beforeSwap, 
					// but simple removal might be okay if elements are garbage collected.
					// container._inputOtpCleanup = () => { ... remove listeners ... };
				};

				// --- HTMX Integration ---
				document.body.addEventListener('htmx:afterSwap', (event) => {
					const target = event.detail.target || event.target;
					if (target?.querySelectorAll) {
						if (target.matches && target.matches('[data-input-otp]')) {
							setupInputOTP(target);
						}
						target.querySelectorAll('[data-input-otp]').forEach(setupInputOTP);
					}
				});

				document.body.addEventListener('htmx:beforeSwap', (event) => {
					const target = event.detail.target || event.detail.elt;
					// Basic cleanup: If a container has a specific cleanup function, call it.
					// More robust cleanup might be needed depending on complexity.
					if (target?.querySelectorAll) {
						const cleanup = (el) => {
							if (el.matches && el.matches('[data-input-otp]') && typeof el._inputOtpCleanup === 'function') {
								el._inputOtpCleanup();
							}
						};
						if (target.matches && target.matches('[data-input-otp]')) cleanup(target);
						target.querySelectorAll('[data-input-otp]').forEach(cleanup);
					}
				});

				// --- Init ---
				const initializeAllInputOTPs = () => {
					document.querySelectorAll('[data-input-otp]').forEach(setupInputOTP);
				};

				if (document.readyState === 'complete' || document.readyState === 'interactive') {
					initializeAllInputOTPs();
				} else {
					document.addEventListener('DOMContentLoaded', initializeAllInputOTPs);
				}

			} // End of window.inputOTPHandlerAttached check
		</script>
	}
}
