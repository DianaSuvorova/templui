package inputotp

import (
	"github.com/axzilla/templui/util"
	"strconv"
)

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Value      string
	Required   bool
	Name       string
	HasError   bool
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type SlotProps struct {
	ID          string
	Class       string
	Attributes  templ.Attributes
	Index       int
	Type        string
	Placeholder string
	Disabled    bool
}

type SeparatorProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

templ InputOTP(props ...Props) {
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID + "-container" }
		}
		if p.Value != "" {
			data-value={ p.Value }
		}
		class={
			util.TwMerge(
				"flex flex-row items-center gap-2 w-fit",
				p.Class,
			),
		}
		data-input-otp
		{ p.Attributes... }
	>
		<input
			type="hidden"
			if p.ID != "" {
				id={ p.ID }
			}
			if p.Name != "" {
				name={ p.Name }
			}
			data-input-otp-value-target
			required?={ p.Required }
		/>
		{ children... }
	</div>
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"flex gap-2",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Slot(props ...SlotProps) {
	{{ var p SlotProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Type == "" {
		{{ p.Type = "text" }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class="relative"
		{ p.Attributes... }
	>
		<input
			type={ p.Type }
			inputmode="numeric"
			if p.Placeholder != "" {
				placeholder={ p.Placeholder }
			}
			maxlength="1"
			class={
				util.TwMerge(
					"w-10 h-12 text-center",
					"rounded-md border border-input bg-background text-sm",
					"file:border-0 file:bg-transparent file:text-sm file:font-medium",
					"placeholder:text-muted-foreground",
					"focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
					"disabled:cursor-not-allowed disabled:opacity-50",
					p.Class,
				),
			}
			disabled?={ p.Disabled }
			data-input-index={ strconv.Itoa(p.Index) }
			data-input-otp-slot
		/>
	</div>
}

templ Separator(props ...SeparatorProps) {
	{{ var p SeparatorProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"flex items-center text-muted-foreground text-xl",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		<span>-</span>
	</div>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script nonce={ templ.GetNonce(ctx) }>
			if (typeof window.inputOTPState === 'undefined') {
				window.inputOTPState = new WeakMap();
			}
			
			(function() { 
				function initInputOTP(container) {
					// Basic elements
					const hiddenInput = container.querySelector('[data-input-otp-value-target]');
					const slots = Array.from(container.querySelectorAll('[data-input-otp-slot]'))
						.sort((a, b) => parseInt(a.dataset.inputIndex) - parseInt(b.dataset.inputIndex));
					
					if (!hiddenInput || slots.length === 0) return;
					
					// Core functionality
					function updateHiddenValue() {
						hiddenInput.value = slots.map(slot => slot.value).join('');
					}
					
					function findFirstEmptySlotIndex() {
						return slots.findIndex(slot => !slot.value);
					}
					
					function handleInput(e) {
						const input = e.target;
						const index = parseInt(input.dataset.inputIndex);
						
						// Prevent space character
						if (input.value === ' ') {
							input.value = '';
							return;
						}
						
						// Limit to single character
						if (input.value.length > 1) {
							input.value = input.value.slice(-1);
						}
						
						// Auto-advance to next slot
						if (input.value && index < slots.length - 1) {
							slots[index + 1].focus();
						}
						
						updateHiddenValue();
					}
					
					function handleKeydown(e) {
						const input = e.target;
						const index = parseInt(input.dataset.inputIndex);
						
						// Handle backspace
						if (e.key === 'Backspace') {
							const currentValue = input.value;
							if (index > 0) {
								e.preventDefault();
								
								if (currentValue) {
									input.value = '';
									updateHiddenValue();
									focusSlot(index - 1);
								} else {
									// If current was empty, clear previous and focus it
									slots[index - 1].value = '';
									updateHiddenValue(); 
									focusSlot(index - 1);
								}
							}
						}
						
						// Arrow key navigation
						if (e.key === 'ArrowLeft' && index > 0) {
							e.preventDefault();
							focusSlot(index - 1);
						}
						
						if (e.key === 'ArrowRight' && index < slots.length - 1) {
							e.preventDefault();
							focusSlot(index + 1);
						}
					}
					
					function focusSlot(index) {
						if (index >= 0 && index < slots.length) {
							slots[index].focus();
							setTimeout(() => slots[index].select(), 0);
						}
					}
					
					function handleFocus(e) {
						const input = e.target;
						const index = parseInt(input.dataset.inputIndex);
						const firstEmptyIndex = findFirstEmptySlotIndex();
						
						// Redirect focus to first empty slot if needed
						if (firstEmptyIndex !== -1 && index !== firstEmptyIndex) {
							focusSlot(firstEmptyIndex);
							return;
						}
						
						input.select();
					}
					
					function handlePaste(e) {
						e.preventDefault();
						
						const pastedData = (e.clipboardData || window.clipboardData).getData('text');
						const pastedChars = pastedData.replace(/\s/g, '').split('');
						
						// Fill slots with pasted characters
						let currentSlot = 0;
						for (let i = 0; i < pastedChars.length && currentSlot < slots.length; i++) {
							slots[currentSlot].value = pastedChars[i];
							currentSlot++;
						}
						
						// Focus appropriately after paste
						let focusIndex = findFirstEmptySlotIndex();
						if (focusIndex === -1) {
							focusIndex = slots.length - 1;
						}
						
						focusSlot(focusIndex);
						updateHiddenValue();
					}
					
					// Add all event listeners
					for (const slot of slots) {
						slot.addEventListener('input', handleInput);
						slot.addEventListener('keydown', handleKeydown);
						slot.addEventListener('focus', handleFocus);
					}
					
					// Paste event on container for delegation
					container.addEventListener('paste', handlePaste);
					
					// Set up label click handling
					const targetId = hiddenInput.id;
					if (targetId) {
						for (const label of document.querySelectorAll(`label[for="${targetId}"]`)) {
							if (!label.dataset.inputOtpListener) {
								label.addEventListener('click', e => {
									e.preventDefault();
									if (slots.length > 0) focusSlot(0);
								});
								label.dataset.inputOtpListener = 'true';
							}
						}
					}
					
					// Initial value handling
					if (container.dataset.value) {
						const initialValue = container.dataset.value;
						for (let i = 0; i < slots.length; i++) {
							if (i < initialValue.length) {
								slots[i].value = initialValue[i];
							}
						}
						updateHiddenValue();
					}
					
					// Store event handlers for potential cleanup
					const state = {
						slots,
						hiddenInput,
						handlers: { handleInput, handleKeydown, handleFocus, handlePaste }
					};
					
					window.inputOTPState.set(container, state);
				}
				
				// Handle cleanup before HTMX swap
				function cleanupInputOTP(container) {
					const state = window.inputOTPState.get(container);
					if (!state) return;
					
					// Remove all event listeners
					for (const slot of state.slots) {
						slot.removeEventListener('input', state.handlers.handleInput);
						slot.removeEventListener('keydown', state.handlers.handleKeydown);
						slot.removeEventListener('focus', state.handlers.handleFocus);
					}
					
					container.removeEventListener('paste', state.handlers.handlePaste);
					
					// Clean up state
					window.inputOTPState.delete(container);
				}
				
				function initAllInputOTP(root = document) {
					const containers = root.querySelectorAll('[data-input-otp]');
					for (const container of containers) {
						// Check if already initialized for this container
						if (!window.inputOTPState.has(container)) {
							initInputOTP(container);
						}
					}
				}
				
				// HTMX cleanup before swap
				document.body.addEventListener('htmx:beforeSwap', (evt) => {
					const target = evt.detail.target;
					if (!target) return;
					
					// Clean up elements being removed or within the target
					if (target.matches && target.matches('[data-input-otp]')) {
						cleanupInputOTP(target);
					}
					// Also cleanup descendants in case the target itself isn't the OTP container
					for (const container of target.querySelectorAll('[data-input-otp]')) {
						cleanupInputOTP(container);
					}
				});
				
				// Initialize after HTMX swaps
				document.body.addEventListener('htmx:afterSwap', (evt) => {
					if (evt.target) {
						// Use setTimeout to ensure the new content is fully in the DOM
						setTimeout(() => initAllInputOTP(evt.target), 0);
					}
				});
				
				// Initialize on DOM load
				document.addEventListener('DOMContentLoaded', () => {
					initAllInputOTP();
				});
				
				// Initialize immediately if DOM is already ready
				if (document.readyState === 'complete' || document.readyState === 'interactive') {
					initAllInputOTP();
				}
			})();
		</script>
	}
}
