package avatar

import (
	"fmt"
	"github.com/axzilla/templui/util"
	"strings"
)

type Size string
type GroupSpacing string

const (
	SizeSm Size = "sm"
	SizeMd Size = "md"
	SizeLg Size = "lg"
)

const (
	GroupSpacingSm GroupSpacing = "sm"
	GroupSpacingMd GroupSpacing = "medium"
	GroupSpacingLg GroupSpacing = "large"
)

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Size       Size
	InGroup    bool
}

type ImageProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Alt        string
	Src        string
}

type FallbackProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Spacing    GroupSpacing
}

templ Avatar(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		data-avatar
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"inline-flex items-center justify-center",
				SizeClasses(p.Size),
				"rounded-full bg-muted",
				util.If(p.InGroup, "ring-2 ring-background"),
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Image(props ...ImageProps) {
	{{ var p ImageProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<img
		data-avatar-image
		if p.ID != "" {
			id={ p.ID }
		}
		if p.Src != "" {
			src={ p.Src }
		}
		alt={ avatarAlt(p) }
		class={
			util.TwMerge(
				"w-full h-full",
				"rounded-full object-cover",
				p.Class,
			),
		}
		{ p.Attributes... }
	/>
}

templ Fallback(props ...FallbackProps) {
	{{ var p FallbackProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<span
		data-avatar-fallback
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"font-medium text-muted-foreground",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</span>
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"flex items-center -space-x-3",
				groupSpacingClasses(p.Spacing),
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ GroupOverflow(count int, props ...Props) {
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={
			util.TwMerge(
				"inline-flex items-center justify-center",
				SizeClasses(p.Size),
				"rounded-full bg-muted ring-2 ring-background",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		<span class="text-xs font-medium">+{ fmt.Sprint(count) }</span>
	</div>
}

func SizeClasses(size Size) string {
	switch size {
	case SizeSm:
		return "w-8 h-8 text-xs"
	case SizeLg:
		return "w-16 h-16 text-xl"
	default: // SizeMd
		return "w-12 h-12 text-base"
	}
}

func Initials(name string) string {
	parts := strings.Fields(name)
	initials := ""
	for i, part := range parts {
		if i > 1 {
			break
		}
		if len(part) > 0 {
			initials += string(part[0])
		}
	}
	return strings.ToUpper(initials)
}

func groupSpacingClasses(spacing GroupSpacing) string {
	switch spacing {
	case GroupSpacingSm:
		return "-space-x-1"
	case GroupSpacingLg:
		return "-space-x-4"
	default: // GroupSpacingMd
		return "-space-x-2"
	}
}

func avatarAlt(p ImageProps) string {
	if p.Alt != "" {
		return p.Alt
	}

	if p.ID != "" {
		return fmt.Sprintf("Avatar of %s", p.ID)
	}

	if p.Src != "" {
		return "User avatar"
	}

	return ""
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			function initAvatarElement(avatar) {
				if (!avatar || avatar.dataset.avatarInitialized) {
					return; // Already initialized or invalid element
				}
				avatar.dataset.avatarInitialized = 'true';

				const image = avatar.querySelector("[data-avatar-image]");
				const fallback = avatar.querySelector("[data-avatar-fallback]");

				if (image && fallback) {
					image.style.display = 'none';
					fallback.style.display = 'none';

					const showFallback = () => {
						image.style.display = 'none';
						fallback.style.display = '';
					};

					const showImage = () => {
						image.style.display = '';
						fallback.style.display = 'none';
					};

					// Check initial state
					if (image.complete) {
						if (image.naturalWidth > 0 && image.naturalHeight > 0) {
							showImage();
						} else {
							showFallback();
						}
					} else {
						// Add listeners only if not already loaded
						image.addEventListener('load', showImage, { once: true }); // Use { once: true } to auto-remove
						image.addEventListener('error', showFallback, { once: true }); // Use { once: true } to auto-remove
						// As a safety net, if the browser already cached the error/load state
						// and the event doesn't fire, re-check after a small delay.
						// This addresses some edge cases in certain browsers.
						setTimeout(() => {
							if (!image.complete) {
								// If still not complete, assume error (e.g., network issue before listeners attached)
								// showFallback(); // Be cautious with this, could cause flicker.
							} else if (!(image.naturalWidth > 0 && image.naturalHeight > 0)) {
								showFallback();
							}
						}, 50);
					}
				} else if (fallback) {
					// If there's only a fallback, ensure it's visible
					fallback.style.display = '';
				} else if (image) {
					// If there's only an image, ensure it's visible
					image.style.display = '';
				}
			}

			// --- Initialization Triggers ---

			function initializeAllAvatars() {
				document.querySelectorAll('[data-avatar]:not([data-avatar-initialized])').forEach(initAvatarElement);
			}

			// 1. Initial page load
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeAllAvatars);
			} else {
				initializeAllAvatars(); // Already loaded
			}

			// 2. After HTMX swaps
			document.body.addEventListener('htmx:afterSwap', function(event) {
				const targetElement = event.target;
				if (targetElement instanceof Element) {
					// Check if the swapped element itself is an avatar
					if (targetElement.matches('[data-avatar]:not([data-avatar-initialized])')) {
						initAvatarElement(targetElement);
					}
					// Check for avatars within the swapped element
					targetElement.querySelectorAll('[data-avatar]:not([data-avatar-initialized])').forEach(initAvatarElement);
				}
			});
		</script>
	}
}
