package datepicker

import (
	"github.com/axzilla/templui/component/button"
	"github.com/axzilla/templui/component/popover"
	"github.com/axzilla/templui/icon"
	"github.com/axzilla/templui/util"
	"time"
)

type Format string

const (
	FormatISO  Format = "iso"
	FormatEU   Format = "eu"
	FormatUK   Format = "uk"
	FormatUS   Format = "us"
	FormatLONG Format = "long"
)

var formatMapping = map[Format]string{
	FormatISO:  "2006-01-02",
	FormatEU:   "02.01.2006",
	FormatUK:   "02/01/2006",
	FormatUS:   "01/02/2006",
	FormatLONG: "January 2, 2006",
}

type Locale struct {
	MonthNames []string
	DayNames   []string
}

var (
	LocaleDefault = Locale{
		MonthNames: []string{"January", "February", "March", "April", "May", "June",
			"July", "August", "September", "October", "November", "December"},
		DayNames: []string{"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"},
	}

	LocaleSpanish = Locale{
		MonthNames: []string{"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
			"Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"},
		DayNames: []string{"Lu", "Ma", "Mi", "Ju", "Vi", "Sa", "Do"},
	}

	LocaleGerman = Locale{
		MonthNames: []string{"Januar", "Februar", "März", "April", "Mai", "Juni",
			"Juli", "August", "September", "Oktober", "November", "Dezember"},
		DayNames: []string{"So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"},
	}

	LocaleFrench = Locale{
		MonthNames: []string{"Janvier", "Février", "Mars", "Avril", "Mai", "Juin",
			"Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"},
		DayNames: []string{"Lu", "Ma", "Me", "Je", "Ve", "Sa", "Di"},
	}

	LocaleItalian = Locale{
		MonthNames: []string{"Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
			"Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"},
		DayNames: []string{"Lu", "Ma", "Me", "Gi", "Ve", "Sa", "Do"},
	}

	LocaleJapanese = Locale{
		MonthNames: []string{"1月", "2月", "3月", "4月", "5月", "6月",
			"7月", "8月", "9月", "10月", "11月", "12月"},
		DayNames: []string{"日", "月", "火", "水", "木", "金", "土"},
	}
)

var (
	ConfigISO = Config{
		Format: FormatISO,
		Locale: LocaleDefault,
	}

	ConfigEU = Config{
		Format: FormatEU,
		Locale: LocaleDefault,
	}

	ConfigUK = Config{
		Format: FormatUK,
		Locale: LocaleDefault,
	}

	ConfigUS = Config{
		Format: FormatUS,
		Locale: LocaleDefault,
	}

	ConfigLONG = Config{
		Format: FormatLONG,
		Locale: LocaleDefault,
	}
)

func NewConfig(format Format, locale Locale) Config {
	return Config{
		Format: format,
		Locale: locale,
	}
}

type Config struct {
	Format Format
	Locale Locale
}

type Props struct {
	ID          string
	Class       string
	Attributes  templ.Attributes
	Value       time.Time
	Config      Config
	Placeholder string
	Disabled    bool
	Required    bool
	HasError    bool
	Name        string
}

templ DatePicker(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	if p.Placeholder == "" {
		{{ p.Placeholder = "Select a date" }}
	}
	// Generate IDs for popover linkage
	{{ var contentID = p.ID + "-content" }}
	<input
		type="hidden"
		id={ p.ID + "-hidden" }
		name={ p.Name }
		data-datepicker-hidden-input
		if p.Value != (time.Time{}) {
			value={ p.Value.Format("2006-01-02") }
		}
		disabled?={ p.Disabled }
		required?={ p.Required }
	/>
	@popover.Popover() {
		@popover.Trigger(popover.TriggerProps{
			For: contentID,
		}) {
			@button.Button(button.Props{
				ID:      p.ID,
				Variant: button.VariantOutline,
				Class: util.TwMerge(
					"w-full select-trigger flex items-center justify-between focus:ring-2 focus:ring-offset-2",
					util.If(p.HasError, "border-destructive ring-destructive"),
					p.Class,
				),
				Disabled: p.Disabled,
			}) {
				<span
					data-datepicker-display
					class="text-left grow"
				>
					if p.Value != (time.Time{}) {
						{ p.Value.Format(p.Config.getGoFormat()) }
					} else {
						<span class="text-muted-foreground">{ p.Placeholder }</span>
					}
				</span>
				<span class="text-muted-foreground flex items-center">
					@icon.Calendar(icon.Props{
						Size: 16,
					})
				</span>
			}
		}
		@popover.Content(popover.ContentProps{
			ID:        contentID, // Link from trigger
			Placement: popover.PlacementBottomStart,
			Class:     "p-3",
		}) {
			<div
				data-datepicker-container
				if p.Value != (time.Time{}) {
					data-value={ p.Value.Format(p.Config.getGoFormat()) }
				} else {
					data-value=""
				}
				data-format={ string(p.Config.Format) }
				data-monthnames={ templ.JSONString(p.Config.Locale.MonthNames) }
				data-daynames={ templ.JSONString(p.Config.Locale.DayNames) }
				data-placeholder={ p.Placeholder }
			>
				<div class="flex items-center justify-between mb-2">
					<span data-datepicker-month-display class="text-sm font-medium"></span>
					<div class="flex gap-1">
						<button
							type="button"
							data-datepicker-prev
							class={ util.TwMerge(
										"inline-flex items-center justify-center rounded-md text-sm font-medium",
										"ring-offset-background transition-colors",
										"focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
										"disabled:pointer-events-none disabled:opacity-50",
										"hover:bg-accent hover:text-accent-foreground",
										"h-7 w-7",
									) }
						>
							@icon.ChevronLeft()
						</button>
						<button
							type="button"
							data-datepicker-next
							class={ util.TwMerge(
										"inline-flex items-center justify-center rounded-md text-sm font-medium",
										"ring-offset-background transition-colors",
										"focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
										"disabled:pointer-events-none disabled:opacity-50",
										"hover:bg-accent hover:text-accent-foreground",
										"h-7 w-7",
									) }
						>
							@icon.ChevronRight()
						</button>
					</div>
				</div>
				<div data-datepicker-weekdays class="grid grid-cols-7 gap-1 mb-1"></div>
				<div data-datepicker-days class="grid grid-cols-7 gap-1"></div>
			</div>
		}
	}
}

// Get the Go format string for the given format
func (c Config) getGoFormat() string {
	if format, ok := formatMapping[c.Format]; ok {
		return format
	}
	return formatMapping[FormatISO]
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			function initializeAllDatePickersInScope(scopeElement) {
				scopeElement.querySelectorAll('[data-datepicker-container]').forEach(container => {
					// Prevent re-initialization
					if (container._datePickerInitialized) return;

					const popoverContentElement = container.closest('[data-popover-id]');
					if (popoverContentElement) {
						try {
							initializeDatePicker(container, popoverContentElement);
							container._datePickerInitialized = true; // Mark as initialized
						} catch (e) {
							console.error("Error initializing datepicker:", e, container);
						}
					} else {
						console.warn("DatePicker container found without a parent popover content element:", container);
					}
				});
			}

			// --- Core DatePicker Logic (Keep User's Version Intact) ---
			function initializeDatePicker(container, popoverContentElement) {
				const datePickerIDBase = popoverContentElement.id.replace('-content', '');
				const associatedHiddenInput = document.getElementById(datePickerIDBase + '-hidden');
				const triggerButton = document.getElementById(datePickerIDBase);
				const displayText = triggerButton ? triggerButton.querySelector('[data-datepicker-display]') : null;

				const monthDisplay = container.querySelector('[data-datepicker-month-display]');
				const weekdaysContainer = container.querySelector('[data-datepicker-weekdays]');
				const daysContainer = container.querySelector('[data-datepicker-days]');
				const prevButton = container.querySelector('[data-datepicker-prev]');
				const nextButton = container.querySelector('[data-datepicker-next]');

				if (!popoverContentElement || !monthDisplay || !weekdaysContainer || !daysContainer || !prevButton || !nextButton || !associatedHiddenInput || !displayText) {
					console.error('DatePicker missing required elements. Check IDs and selectors.', {
						container, popoverContentElement, monthDisplay, weekdaysContainer, daysContainer, prevButton, nextButton, associatedHiddenInput, displayText, datePickerIDBase
					});
					return;
				}

				let config = {
					value: container.dataset.value || null,
					format: container.dataset.format || 'iso',
					monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
					dayNames: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
					placeholder: container.dataset.placeholder || 'Select a date',
				};

				try {
					const parsedMonths = JSON.parse(container.dataset.monthnames || '[]');
					if (parsedMonths.length === 12) config.monthNames = parsedMonths;
					const parsedDays = JSON.parse(container.dataset.daynames || '[]');
					if (parsedDays.length === 7) config.dayNames = parsedDays;
				} catch (e) { console.error('Error parsing datepicker locale:', e); }

				let selectedDate = config.value ? parseDate(config.value, config.format) : null;
				if (selectedDate && isNaN(selectedDate.getTime())) selectedDate = null;

				let viewDate = selectedDate ? new Date(selectedDate) : new Date();
				if (isNaN(viewDate.getTime())) viewDate = new Date();

				let currentMonth = viewDate.getMonth();
				let currentYear = viewDate.getFullYear();

				function parseDate(dateStr, format) {
					if (!dateStr) return null;
					const parts = dateStr.split(/[-/. ]/);
					let year, month, day;
					try {
						switch(format) {
							case 'eu': day = parseInt(parts[0], 10); month = parseInt(parts[1], 10) - 1; year = parseInt(parts[2], 10); break;
							case 'uk': day = parseInt(parts[0], 10); month = parseInt(parts[1], 10) - 1; year = parseInt(parts[2], 10); break;
							case 'us': month = parseInt(parts[0], 10) - 1; day = parseInt(parts[1], 10); year = parseInt(parts[2], 10); break;
							case 'long': const parsed = new Date(dateStr); return !isNaN(parsed) ? parsed : null;
							case 'iso': default: year = parseInt(parts[0], 10); month = parseInt(parts[1], 10) - 1; day = parseInt(parts[2], 10); break;
						}
						const date = new Date(year, month, day);
						// Basic validation: Check if the parsed date components match the input
						if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
							return date;
						} return null;
					} catch (e) { console.error("Date parsing error:", e); return null; }
				}

				function formatDate(date, format, monthNames) {
					if (!date || isNaN(date.getTime())) return '';
					const d = date.getDate();
					const dd = d.toString().padStart(2, '0');
					const m = date.getMonth();
					const mm = (m + 1).toString().padStart(2, '0');
					const y = date.getFullYear();
					switch(format) {
						case 'eu': return `${dd}.${mm}.${y}`;
						case 'uk': return `${dd}/${mm}/${y}`;
						case 'us': return `${mm}/${dd}/${y}`;
						case 'long': return `${monthNames[m]} ${d}, ${y}`;
						case 'iso': default: return `${y}-${mm}-${dd}`;
					}
				}

				function updateDisplayText() {
					if (!displayText) return; // Guard against missing element
					displayText.innerHTML = '';
					if (selectedDate) {
						displayText.textContent = formatDate(selectedDate, config.format, config.monthNames);
						const placeholderSpan = displayText.querySelector('.text-muted-foreground');
						if(placeholderSpan) placeholderSpan.remove();
						displayText.classList.remove('text-muted-foreground');
					} else {
						const span = document.createElement('span');
						span.className = 'text-muted-foreground';
						span.textContent = config.placeholder;
						displayText.appendChild(span);
					}
				}

				function updateMonthDisplay() {
					monthDisplay.textContent = `${config.monthNames[currentMonth]} ${currentYear}`;
				}

				function renderWeekdays() {
					weekdaysContainer.innerHTML = '';
					config.dayNames.forEach(day => {
						const el = document.createElement('div');
						el.className = 'text-center text-xs text-muted-foreground font-medium';
						el.textContent = day;
						weekdaysContainer.appendChild(el);
					});
				}

				function renderCalendar() {
					daysContainer.innerHTML = '';
					const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
					const firstDayWeekday = firstDayOfMonth.getDay(); // 0=Sun

					// Adjust starting offset based on whether config.dayNames starts with Sunday or Monday
					let startOffset = firstDayWeekday;
					if (config.dayNames[0].toLowerCase() !== 'su') { // Assumes Monday start if not Sunday
						startOffset = (firstDayWeekday === 0) ? 6 : firstDayWeekday - 1;
					}

					const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
					const today = new Date();
					today.setHours(0, 0, 0, 0); // Compare with local date

					for (let i = 0; i < startOffset; i++) {
						const blank = document.createElement('div');
						blank.className = 'h-8 w-8';
						daysContainer.appendChild(blank);
					}

					for (let day = 1; day <= daysInMonth; day++) {
						const button = document.createElement('button');
						button.type = 'button';
						button.className = 'inline-flex h-8 w-8 items-center justify-center rounded-md text-sm font-medium focus:outline-none focus:ring-1 focus:ring-ring'; // Base + focus
						button.textContent = day;
						button.dataset.day = day;

						const currentDate = new Date(currentYear, currentMonth, day);
						currentDate.setHours(0,0,0,0);

						const isToday = currentDate.getTime() === today.getTime();
						const isSelected = selectedDate && currentDate.getTime() === selectedDate.getTime();

						if (isSelected) {
							button.classList.add('bg-primary', 'text-primary-foreground', 'hover:bg-primary/90');
						} else if (isToday) {
							// Use the style from user's last change
							button.classList.add('text-primary', 'font-bold', 'bg-muted');
						} else {
							button.classList.add('hover:bg-accent', 'hover:text-accent-foreground');
						}

						button.addEventListener('click', handleDayClick);
						daysContainer.appendChild(button);
					}
				}

				function handlePrevMonthClick() {
					currentMonth--;
					if (currentMonth < 0) { currentMonth = 11; currentYear--; }
					updateMonthDisplay(); renderCalendar();
				}

				function handleNextMonthClick() {
					currentMonth++;
					if (currentMonth > 11) { currentMonth = 0; currentYear++; }
					updateMonthDisplay(); renderCalendar();
				}

				function handleDayClick(event) {
					const day = parseInt(event.target.dataset.day);
					if (!day) return;

					selectedDate = new Date(currentYear, currentMonth, day);
					selectedDate.setHours(0,0,0,0);

					const displayFormattedValue = formatDate(selectedDate, config.format, config.monthNames);

					const isoFormattedValue = formatDate(selectedDate, 'iso', config.monthNames);

					if (associatedHiddenInput) {
						associatedHiddenInput.value = isoFormattedValue;
						associatedHiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
					}

					updateDisplayText();

					if (triggerButton) {
						triggerButton.click();
					}
				}

				prevButton.addEventListener('click', handlePrevMonthClick);
				nextButton.addEventListener('click', handleNextMonthClick);

				updateDisplayText();
				updateMonthDisplay();
				renderWeekdays();
				renderCalendar();

				const observer = new MutationObserver((mutationsList) => {
					for(let mutation of mutationsList) {
						if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
							if (popoverContentElement.style.display !== 'none') {
								viewDate = selectedDate ? new Date(selectedDate) : new Date();
								if (isNaN(viewDate.getTime())) viewDate = new Date();
								currentMonth = viewDate.getMonth();
								currentYear = viewDate.getFullYear();
								updateMonthDisplay();
								renderCalendar();
							}
						}
					}
				});
				observer.observe(popoverContentElement, { attributes: true });
				container._datePickerObserver = observer;

			} // End initializeDatePicker


			document.addEventListener('DOMContentLoaded', () => {
				initializeAllDatePickersInScope(document.body);
			});

			// HTMX cleanup logic (Keep as is)
			document.body.addEventListener('htmx:beforeSwap', (event) => {
				let target = event.detail.target || event.detail.elt;
				if (target && target.matches && target.querySelectorAll) {
					// Check if the swapped element itself is a datepicker container
					if (target.matches('[data-datepicker-container]') && target._datePickerObserver) {
						target._datePickerObserver.disconnect();
						delete target._datePickerObserver;
					}
					// Check for datepicker containers within the swapped element
					target.querySelectorAll('[data-datepicker-container]').forEach(container => {
						if (container._datePickerObserver) {
							container._datePickerObserver.disconnect();
							delete container._datePickerObserver;
						}
					});
				}
			});

			// HTMX Integration: Initialize after swap
			document.body.addEventListener('htmx:afterSwap', (event) => {
				const target = event.detail.target || event.target;
				// Ensure target is an element capable of containing datepickers
				if (target instanceof Element) {
					initializeAllDatePickersInScope(target);
				}
			});
		</script>
	}
}
