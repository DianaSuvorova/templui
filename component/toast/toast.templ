package toast

import (
	"github.com/axzilla/templui/component/button"
	"github.com/axzilla/templui/icon"
	"github.com/axzilla/templui/util"
	"strconv"
)

type Variant string
type Position string

const (
	VariantDefault Variant = "default"
	VariantSuccess Variant = "success"
	VariantError   Variant = "error"
	VariantWarning Variant = "warning"
	VariantInfo    Variant = "info"
)

const (
	PositionTopRight     Position = "top-right"
	PositionTopLeft      Position = "top-left"
	PositionTopCenter    Position = "top-center"
	PositionBottomRight  Position = "bottom-right"
	PositionBottomLeft   Position = "bottom-left"
	PositionBottomCenter Position = "bottom-center"
)

type Props struct {
	ID            string
	Class         string
	Attributes    templ.Attributes
	Title         string
	Description   string
	Variant       Variant
	Position      Position
	Duration      int
	Dismissible   bool
	ShowIndicator bool
	Icon          bool
}

templ Toast(props ...Props) {
	@Script()
	@ToastCSS()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	{{ p = p.defaults() }}
	{{ isTop := p.Position == PositionTopRight || p.Position == PositionTopLeft || p.Position == PositionTopCenter }}
	{{ isBottom := p.Position == PositionBottomRight || p.Position == PositionBottomLeft || p.Position == PositionBottomCenter }}
	<div
		id={ p.ID }
		data-toast
		data-duration={ strconv.Itoa(p.Duration) }
		class={ util.TwMerge(
			"z-50 fixed pointer-events-auto p-4",
			"opacity-0 transform transition-all duration-300 ease-out",
			util.If(isTop, "top-0"),
			util.If(isBottom, "bottom-0"),
			util.If(isTop, "translate-y-4"),
			util.If(isBottom, "-translate-y-4"),
			util.If(p.Position == PositionTopRight || p.Position == PositionBottomRight, "right-0"),
			util.If(p.Position == PositionTopLeft || p.Position == PositionBottomLeft, "left-0"),
			util.If(p.Position == PositionTopCenter || p.Position == PositionBottomCenter, "left-1/2 -translate-x-1/2"),
			"w-full md:max-w-[420px]",
			p.Class,
		) }
		{ p.Attributes... }
	>
		<div class="w-full bg-primary-foreground rounded-lg shadow-xs border pt-5 pb-4 px-4 flex items-center justify-center relative overflow-hidden">
			if p.ShowIndicator {
				@indicator(p)
			}
			if p.Icon {
				@toastIcon(p)
			}
			<span class="flex-1 min-w-0">
				@title(p)
				@description(p)
			</span>
			if p.Dismissible {
				@dismissButton()
			}
		</div>
	</div>
}

templ indicator(p Props) {
	<div class="absolute top-0 left-0 right-0 h-1">
		<div
			data-toast-progress
			class={ util.TwMerge(
				"absolute inset-0",
				typeClass(p.Variant),
			) }
		></div>
	</div>
}

templ toastIcon(p Props) {
	if p.Variant == VariantSuccess {
		@icon.CircleCheck(icon.Props{Size: 22, Class: "text-green-500 mr-3 flex-shrink-0"})
	} else if p.Variant == VariantError {
		@icon.CircleX(icon.Props{Size: 22, Class: "text-red-500 mr-3 flex-shrink-0"})
	} else if p.Variant == VariantWarning {
		@icon.TriangleAlert(icon.Props{Size: 22, Class: "text-yellow-500 mr-3 flex-shrink-0"})
	} else if p.Variant == VariantInfo {
		@icon.Info(icon.Props{Size: 22, Class: "text-blue-500 mr-3 flex-shrink-0"})
	}
}

templ title(p Props) {
	if p.Title != "" {
		<p class="text-sm font-semibold truncate">{ p.Title }</p>
	}
}

templ description(p Props) {
	if p.Description != "" {
		<p class="text-sm opacity-90 mt-1">{ p.Description }</p>
	}
}

templ dismissButton() {
	@button.Button(button.Props{
		Size:    button.SizeIcon,
		Variant: button.VariantGhost,
		Attributes: templ.Attributes{
			"aria-label":         "Close",
			"data-toast-dismiss": "",
			"type":               "button",
		},
	}) {
		@icon.X(icon.Props{
			Size:  18,
			Class: "opacity-75 hover:opacity-100",
		})
	}
}

func (p Props) defaults() Props {
	if p.Variant == "" {
		p.Variant = VariantDefault
	}
	if p.Position == "" {
		p.Position = PositionBottomRight
	}
	if p.Duration == 0 {
		p.Duration = 3000
	}
	return p
}

func typeClass(t Variant) string {
	switch t {
	case VariantDefault:
		return "bg-gray-500"
	case VariantSuccess:
		return "bg-green-500"
	case VariantError:
		return "bg-red-500"
	case VariantWarning:
		return "bg-yellow-500"
	case VariantInfo:
		return "bg-blue-500"
	default:
		return ""
	}
}

var cssHandle = templ.NewOnceHandle()

templ ToastCSS() {
	@cssHandle.Once() {
		<style nonce={ templ.GetNonce(ctx) }>
			[data-toast].toast-enter {
				opacity: 0;
			}
			[data-toast].toast-enter-active {
				opacity: 1;
				transform: translateY(0) translateX(-50%);
			}
			[data-toast][class*=" right-"].toast-enter-active,
			[data-toast][class*=" left-"].toast-enter-active {
				transform: translateY(0) translateX(0);
			}

			[data-toast].toast-leave {
				opacity: 1;
				transform: translateY(0) translateX(-50%);
			}
			[data-toast][class*=" right-"].toast-leave,
			[data-toast][class*=" left-"].toast-leave {
				transform: translateY(0) translateX(0);
			}

			[data-toast].toast-leave-active {
				opacity: 0;
			}
			[data-toast][class*=" top-"].toast-leave-active {
				transform: translateY(1rem) translateX(-50%);
			}
			[data-toast][class*=" bottom-"].toast-leave-active {
				transform: translateY(-1rem) translateX(-50%);
			}
			[data-toast][class*=" top-"][class*=" right-"].toast-leave-active,
			[data-toast][class*=" top-"][class*=" left-"].toast-leave-active {
				transform: translateY(1rem) translateX(0);
			}
			[data-toast][class*=" bottom-"][class*=" right-"].toast-leave-active,
			[data-toast][class*=" bottom-"][class*=" left-"].toast-leave-active {
				transform: translateY(-1rem) translateX(0);
			}
		</style>
	}
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script nonce={ templ.GetNonce(ctx) }>
			// --- Toast Logic ---
			if (typeof window.toastHandlerAttached === 'undefined') {
				window.toastHandlerAttached = true;
				window.activeToasts = new Map(); // Map<element, state>

				const setupToast = (toastEl) => {
					if (window.activeToasts.has(toastEl)) return; // Already initialized

					const duration = parseInt(toastEl.dataset.duration || '0');
					const progressEl = toastEl.querySelector('[data-toast-progress]');
					const dismissBtn = toastEl.querySelector('[data-toast-dismiss]');

					const state = {
						timerId: null,
						remainingDuration: duration,
						startTime: Date.now(),
						progressEl: progressEl,
						isPaused: false
					};
					window.activeToasts.set(toastEl, state);

					const dismissToast = () => {
						clearTimeout(state.timerId);
						toastEl.classList.remove('toast-enter-active');
						toastEl.classList.add('toast-leave-active');
						// Remove element after animation
						toastEl.addEventListener('transitionend', () => {
							if (toastEl.parentNode) {
								toastEl.parentNode.removeChild(toastEl);
							}
							window.activeToasts.delete(toastEl);
						}, { once: true });
					};

					const startTimer = (time) => {
						if (time <= 0) return; // No timer for duration 0 or less
						clearTimeout(state.timerId);
						state.startTime = Date.now();
						state.remainingDuration = time;
						state.isPaused = false;
						state.timerId = setTimeout(dismissToast, time);

						if (state.progressEl) {
							// Ensure transition is set for the new duration
							state.progressEl.style.transition = `width ${time}ms linear`;
							// Force reflow to apply transition correctly after pause
							void state.progressEl.offsetWidth;
							state.progressEl.style.width = '0%';
						}
					};

					const pauseTimer = () => {
						if (state.isPaused || state.remainingDuration <= 0) return;
						clearTimeout(state.timerId);
						const elapsed = Date.now() - state.startTime;
						state.remainingDuration -= elapsed;
						state.isPaused = true;
						if (state.progressEl) {
							// Get current width and stop transition
							const currentWidth = window.getComputedStyle(state.progressEl).width;
							state.progressEl.style.transition = 'none';
							state.progressEl.style.width = currentWidth;
						}
					};

					const resumeTimer = () => {
						if (!state.isPaused || state.remainingDuration <= 0) return;
						startTimer(state.remainingDuration);
					};

					// Add Listeners
					if (duration > 0) { // Only add hover listeners if there's a duration
						toastEl.addEventListener('mouseenter', pauseTimer);
						toastEl.addEventListener('mouseleave', resumeTimer);
					}
					if (dismissBtn) {
						dismissBtn.addEventListener('click', dismissToast);
					}

					// Initial Animation and Timer Start
					// Use setTimeout to allow initial styles to apply before starting transition
					setTimeout(() => {
						toastEl.classList.add('toast-enter-active');
						if (state.progressEl) {
							state.progressEl.style.width = '100%'; // Initial width for animation start
						}
						startTimer(duration);
					}, 50); // Small delay

					// Cleanup function (optional, but good practice)
					toastEl._toastCleanup = () => {
						clearTimeout(state.timerId);
						toastEl.removeEventListener('mouseenter', pauseTimer);
						toastEl.removeEventListener('mouseleave', resumeTimer);
						if (dismissBtn) dismissBtn.removeEventListener('click', dismissToast);
						window.activeToasts.delete(toastEl);
					};
				};

				// --- HTMX Integration ---
				document.body.addEventListener('htmx:afterSwap', (event) => {
					const target = event.detail.target || event.target;
					if (target?.querySelectorAll) {
						if (target.matches && target.matches('[data-toast]')) {
							setupToast(target);
						}
						target.querySelectorAll('[data-toast]').forEach(setupToast);
					}
				});

				document.body.addEventListener('htmx:beforeSwap', (event) => {
					const target = event.detail.target || event.detail.elt;
					if (target?.querySelectorAll) {
						const cleanup = (el) => {
							if (el.matches && el.matches('[data-toast]') && typeof el._toastCleanup === 'function') {
								el._toastCleanup();
							}
						};
						if (target.matches && target.matches('[data-toast]')) cleanup(target);
						target.querySelectorAll('[data-toast]').forEach(cleanup);
					}
				});

				// --- Init ---
				const initializeAllToasts = () => {
					document.querySelectorAll('[data-toast]').forEach(setupToast);
				};

				if (document.readyState === 'complete' || document.readyState === 'interactive') {
					initializeAllToasts();
				} else {
					document.addEventListener('DOMContentLoaded', initializeAllToasts);
				}
			} // End window.toastHandlerAttached check
		</script>
	}
}
