package rating

import (
	"fmt"
	"github.com/axzilla/templui/icon"
	"github.com/axzilla/templui/util"
	"strconv"
)

// --- Types & Constants ---

type Style string

const (
	StyleStar  Style = "star"
	StyleHeart Style = "heart"
	StyleEmoji Style = "emoji"
)

type Props struct {
	ID          string
	Class       string
	Attributes  templ.Attributes
	Value       float64 // Initial value
	ReadOnly    bool
	Precision   float64 // Step for value changes (e.g., 0.5, 1)
	Name        string  // For form submission
	OnlyInteger bool    // If true, snaps to whole numbers on click
}

type GroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ItemProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Value      int   // The integer value this item represents (e.g., 1, 2, 3...)
	Style      Style // Visual style
}

// --- Components ---
templ Rating(props ...Props) {
	@Script()
	// Include the Vanilla JS script
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	{{ p.setDefaults() }}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-rating-component
		data-initial-value={ fmt.Sprintf("%.2f", p.Value) }
		data-precision={ fmt.Sprintf("%.2f", p.Precision) }
		data-readonly={ strconv.FormatBool(p.ReadOnly) }
		if p.Name != "" {
			data-name={ p.Name }
		}
		data-onlyinteger={ strconv.FormatBool(p.OnlyInteger) }
		class={
			util.TwMerge(
				"flex flex-col items-start gap-1",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		{ children... }
		// Expects RatingGroup with RatingItems
		// Hidden input for form submissions
		if p.Name != "" {
			<input
				type="hidden"
				name={ p.Name }
				value={ fmt.Sprintf("%.2f", p.Value) }
				data-rating-input
			/>
		}
	</div>
}

templ Group(props ...GroupProps) {
	{{ var p GroupProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("flex flex-row items-center gap-1", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Item(props ...ItemProps) {
	{{ var p ItemProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	{{ p.setDefaults() }}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		data-rating-item
		data-rating-value={ strconv.Itoa(p.Value) }
		class={
			util.TwMerge(
				"relative",
				colorClass(p.Style),
				"transition-opacity",
				"cursor-pointer", // Default cursor
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		// Background (empty) icon
		<div class="opacity-30">
			@ratingIcon(p.Style, false, float64(p.Value))
		</div>
		// Foreground (filled) icon container
		<div
			class="absolute inset-0 overflow-hidden"
			data-rating-item-foreground
			style="width: 0%;"
		>
			@ratingIcon(p.Style, true, float64(p.Value))
		</div>
	</div>
}

// --- Helpers ---

func colorClass(style Style) string {
	switch style {
	case StyleHeart:
		return "text-destructive"
	case StyleEmoji:
		return "text-yellow-500"
	default:
		return "text-yellow-400"
	}
}

func ratingIcon(style Style, filled bool, value float64) templ.Component {
	// Emoji logic remains the same
	if style == StyleEmoji {
		if filled {
			switch {
			case value <= 1:
				return icon.Angry()
			case value <= 2:
				return icon.Frown()
			case value <= 3:
				return icon.Meh()
			case value <= 4:
				return icon.Smile()
			default:
				return icon.Laugh()
			}
		}
		return icon.Meh()
	}
	// Star/Heart logic remains the same
	iconProps := icon.Props{}
	if filled {
		iconProps.Fill = "currentColor"
	}
	switch style {
	case StyleHeart:
		return icon.Heart(iconProps)
	default:
		return icon.Star(iconProps)
	}
}

func (p *ItemProps) setDefaults() {
	if p.Style == "" {
		p.Style = StyleStar
	}
}

func (p *Props) setDefaults() {
	if p.Precision <= 0 {
		p.Precision = 1.0 // Default to whole numbers
	}
}

// --- Script ---

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			function initializeRating(ratingElement) {
				if (ratingElement.dataset.ratingInitialized === 'true') {
					return; // Already initialized
				}
				ratingElement.dataset.ratingInitialized = 'true';

				const config = {
					value: parseFloat(ratingElement.dataset.initialValue) || 0,
					precision: parseFloat(ratingElement.dataset.precision) || 1,
					readonly: ratingElement.dataset.readonly === 'true',
					name: ratingElement.dataset.name || '',
					onlyInteger: ratingElement.dataset.onlyinteger === 'true',
					maxValue: 0, // Will be calculated
				};

				const hiddenInput = ratingElement.querySelector('[data-rating-input]');
				let items = Array.from(ratingElement.querySelectorAll('[data-rating-item]'));

				let currentValue = config.value;
				let previewValue = 0; // For hover effect

				function calculateMaxValue() {
					let highestValue = 0;
					items.forEach(item => {
						const value = parseInt(item.dataset.ratingValue, 10);
						if (!isNaN(value) && value > highestValue) {
							highestValue = value;
						}
					});
					config.maxValue = Math.max(1, highestValue); // Ensure at least 1
					// Initial value clamping after calculating max value
					currentValue = Math.max(0, Math.min(config.maxValue, currentValue));
					currentValue = Math.round(currentValue / config.precision) * config.precision;
					updateHiddenInput();
				}

				function updateHiddenInput() {
					if (hiddenInput) {
						hiddenInput.value = currentValue.toFixed(2); // Keep consistent format
					}
				}

				function updateItemStyles(displayValue) {
					items.forEach(item => {
						const itemValue = parseInt(item.dataset.ratingValue, 10);
						if (isNaN(itemValue)) return;

						const foreground = item.querySelector('[data-rating-item-foreground]');
						if (!foreground) return;

						const valueToCompare = displayValue > 0 ? displayValue : currentValue;

						const filled = itemValue <= Math.floor(valueToCompare);
						const partial = !filled && (itemValue - 1 < valueToCompare && valueToCompare < itemValue);
						const percentage = partial ? (valueToCompare - Math.floor(valueToCompare)) * 100 : 0;

						foreground.style.width = filled ? '100%' : (partial ? `${percentage}%` : '0%');
					});
				}

				function setValue(itemValue) {
					if (config.readonly) return;

					let newValue = itemValue;
					if (config.onlyInteger) {
						newValue = Math.round(newValue);
					} else {
                        // Allow deselecting by clicking the same full star/item
                        if (currentValue === newValue && newValue % 1 === 0) {
                            newValue = Math.max(0, newValue - config.precision);
                        } else {
                            newValue = Math.round(newValue / config.precision) * config.precision;
                        }
					}

					currentValue = Math.max(0, Math.min(config.maxValue, newValue));
					previewValue = 0; // Reset preview on click
					updateHiddenInput();
					updateItemStyles(0); // Update based on new currentValue

					// Dispatch custom events for potential external listeners
					ratingElement.dispatchEvent(new CustomEvent('rating-change', {
						bubbles: true,
						detail: {
							name: config.name,
							value: currentValue,
							maxValue: config.maxValue
						}
					}));

					// Trigger input/change on hidden field for form libraries
					if (hiddenInput) {
						hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
						hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
					}
				}

				function handleMouseOver(event) {
					if (config.readonly) return;
					const item = event.target.closest('[data-rating-item]');
					if (item) {
						previewValue = parseInt(item.dataset.ratingValue, 10);
						if (!isNaN(previewValue)) {
							updateItemStyles(previewValue);
						}
					}
				}

				function handleMouseLeave() {
					if (config.readonly) return;
					previewValue = 0;
					updateItemStyles(0); // Revert to actual value display
				}

				function handleClick(event) {
					if (config.readonly) return;
					const item = event.target.closest('[data-rating-item]');
					if (item) {
						const itemValue = parseInt(item.dataset.ratingValue, 10);
						if (!isNaN(itemValue)) {
							setValue(itemValue);
						}
					}
				}

				// --- Initialization ---
				calculateMaxValue(); // Calculate max value based on rendered items
				updateItemStyles(0); // Set initial styles based on currentValue

				// Apply readonly styling/behavior
				if (config.readonly) {
					ratingElement.style.cursor = 'default';
					items.forEach(item => item.style.cursor = 'default');
				} else {
					// Use event delegation on the main rating element
					ratingElement.addEventListener('click', handleClick);
					ratingElement.addEventListener('mouseover', handleMouseOver);
					ratingElement.addEventListener('mouseleave', handleMouseLeave);
				}

				// Observe future DOM changes within this rating component
				const observer = new MutationObserver(() => {
                    const currentItemCount = ratingElement.querySelectorAll('[data-rating-item]').length;
                    if (currentItemCount !== items.length) {
                        items = Array.from(ratingElement.querySelectorAll('[data-rating-item]')); // Update item list
                        calculateMaxValue();
                        updateItemStyles(previewValue > 0 ? previewValue : 0); // Update styles respecting preview
                    }
                });
				observer.observe(ratingElement, { childList: true, subtree: true });

                // Optional: Store cleanup function reference on the element
				ratingElement._ratingCleanup = () => {
                    if (!config.readonly) {
                        ratingElement.removeEventListener('click', handleClick);
                        ratingElement.removeEventListener('mouseover', handleMouseOver);
                        ratingElement.removeEventListener('mouseleave', handleMouseLeave);
                    }
                    observer.disconnect();
                };
			}

			// --- Global Initialization Triggers ---

			function initializeAllRatings() {
				document.querySelectorAll('[data-rating-component]:not([data-rating-initialized])').forEach(initializeRating);
			}

			// 1. Initial page load
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeAllRatings);
			} else {
				initializeAllRatings(); // Already loaded
			}

			// 2. After HTMX swaps - Initialize any new rating components loaded via HTMX
			document.body.addEventListener('htmx:afterSwap', function(event) {
				const targetElement = event.target instanceof Element ? event.target : null;
				if (targetElement) {
					// Check if the swapped element itself is a rating component
					if (targetElement.matches('[data-rating-component]:not([data-rating-initialized])')) {
						initializeRating(targetElement);
					}
					// Check for rating components within the swapped content
					targetElement.querySelectorAll('[data-rating-component]:not([data-rating-initialized])').forEach(initializeRating);
				}
			});

			// Optional: Add htmx:beforeSwap listener to cleanup event listeners
			document.body.addEventListener('htmx:beforeCleanup', (event) => {
                let containerToRemove = event.detail.target || event.detail.elt;
                if (containerToRemove && containerToRemove.querySelectorAll) {
                    containerToRemove.querySelectorAll('[data-rating-component][data-rating-initialized]').forEach(ratingEl => {
                        if (typeof ratingEl._ratingCleanup === 'function') {
                            ratingEl._ratingCleanup();
                            delete ratingEl._ratingCleanup; // Remove reference
                            ratingEl.removeAttribute('data-rating-initialized'); // Allow re-initialization if needed
                        }
                    });
                    if (containerToRemove.matches('[data-rating-component][data-rating-initialized]')) {
                         if (typeof containerToRemove._ratingCleanup === 'function') {
                            containerToRemove._ratingCleanup();
                            delete containerToRemove._ratingCleanup;
                            containerToRemove.removeAttribute('data-rating-initialized');
                        }
                    }
                }
            });

		</script>
	}
}
