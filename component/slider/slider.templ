package slider

import (
	"fmt"
	"github.com/axzilla/templui/util"
)

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Name       string
	Min        int
	Max        int
	Step       int
	Value      int
	Disabled   bool
}

type ValueProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	For        string // Corresponds to the ID of the Slider Input
}

templ Slider(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div
		if p.ID != "" {
			id={ p.ID }
		}
		class={ util.TwMerge("w-full", p.Class) }
		data-slider-wrapper
		{ p.Attributes... }
	>
		{ children... }
	</div>
}

templ Input(props ...Props) {
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	<input
		type="range"
		id={ p.ID }
		data-slider-input
		if p.Name != "" {
			name={ p.Name }
		}
		if p.Value != 0 {
			value={ fmt.Sprintf("%d", p.Value) }
		}
		if p.Min != 0 {
			min={ fmt.Sprintf("%d", p.Min) }
		}
		if p.Max != 0 {
			max={ fmt.Sprintf("%d", p.Max) }
		}
		if p.Step != 0 {
			step={ fmt.Sprintf("%d", p.Step) }
		}
		class={
			util.TwMerge(
				"w-full h-2 rounded-full bg-secondary appearance-none cursor-pointer",
				"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
				"[&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4",
				"[&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-primary",
				"[&::-webkit-slider-thumb]:hover:bg-primary/90",
				"[&::-moz-range-thumb]:w-4 [&::-moz-range-thumb]:h-4 [&::-moz-range-thumb]:border-0",
				"[&::-moz-range-thumb]:rounded-full [&::-moz-range-thumb]:bg-primary",
				"[&::-moz-range-thumb]:hover:bg-primary/90",
				"disabled:opacity-50 disabled:cursor-not-allowed",
				p.Class,
			),
		}
		disabled?={ p.Disabled }
		{ p.Attributes... }
	/>
}

templ Value(props ...ValueProps) {
	{{ var p ValueProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.For == "" {
		<span class="text-xs text-destructive">Error: SliderValue missing 'For' attribute.</span>
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		data-slider-value
		data-slider-value-for={ p.For }
		class={ util.TwMerge("text-sm text-muted-foreground", p.Class) }
		{ p.Attributes... }
	>
		<!-- Initial value will be set by JS -->
	</span>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			function initializeSlider(sliderInput) {
				if (sliderInput.dataset.sliderInitialized === 'true') {
					return; // Already initialized
				}
				sliderInput.dataset.sliderInitialized = 'true';

				const sliderId = sliderInput.id;
				if (!sliderId) {
					console.error("Slider input is missing an ID, cannot initialize value display.", sliderInput);
					return;
				}

				// Find associated value display elements specifically for this slider
				const valueElements = document.querySelectorAll(`[data-slider-value][data-slider-value-for="${sliderId}"]`);

				// Function to update the associated value displays
				const updateValueDisplays = () => {
					valueElements.forEach(el => {
						el.textContent = sliderInput.value;
					});
				};

				// Event listener for the input event
				const handleInput = () => {
					updateValueDisplays();
					// Optional: Dispatch a custom event if needed
					// sliderInput.dispatchEvent(new CustomEvent('slider-input', { detail: { value: sliderInput.value }, bubbles: true }));
				};

				// --- Initialization ---
				updateValueDisplays(); // Set initial value display
				sliderInput.addEventListener('input', handleInput);

				// Store cleanup function on the element
				sliderInput._sliderCleanup = () => {
					sliderInput.removeEventListener('input', handleInput);
				};
			}

			// --- Global Initialization Triggers ---

			function initializeAllSliders() {
				// Target the input elements directly
				document.querySelectorAll('input[type="range"][data-slider-input]:not([data-slider-initialized])').forEach(initializeSlider);
			}

			// 1. Initial page load
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeAllSliders);
			} else {
				initializeAllSliders(); // Already loaded
			}

			// 2. After HTMX swaps
			document.body.addEventListener('htmx:afterSwap', function(event) {
				const targetElement = event.target instanceof Element ? event.target : null;
				if (targetElement) {
					// Check if the swapped element itself is a slider input
					if (targetElement.matches('input[type="range"][data-slider-input]:not([data-slider-initialized])')) {
						initializeSlider(targetElement);
					}
					// Check for slider inputs within the swapped content
					targetElement.querySelectorAll('input[type="range"][data-slider-input]:not([data-slider-initialized])').forEach(initializeSlider);
				}
			});

			// 3. Cleanup before HTMX removes elements
			document.body.addEventListener('htmx:beforeCleanup', (event) => {
				let containerToRemove = event.detail.target || event.detail.elt;
				if (containerToRemove && containerToRemove.querySelectorAll) {
					// Cleanup sliders within the container
					containerToRemove.querySelectorAll('input[type="range"][data-slider-input][data-slider-initialized]').forEach(sliderInput => {
						if (typeof sliderInput._sliderCleanup === 'function') {
							sliderInput._sliderCleanup();
							delete sliderInput._sliderCleanup; // Remove the reference
							sliderInput.removeAttribute('data-slider-initialized');
						}
					});
					// Cleanup if the container itself is a slider input
					if (containerToRemove.matches('input[type="range"][data-slider-input][data-slider-initialized]')) {
						if (typeof containerToRemove._sliderCleanup === 'function') {
							containerToRemove._sliderCleanup();
							delete containerToRemove._sliderCleanup;
							containerToRemove.removeAttribute('data-slider-initialized');
						}
					}
				}
			});
		</script>
	}
}
