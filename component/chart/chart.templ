package chart

import "github.com/axzilla/templui/util"

type Variant string

const (
	VariantBar      Variant = "bar"
	VariantLine     Variant = "line"
	VariantPie      Variant = "pie"
	VariantDoughnut Variant = "doughnut"
	VariantRadar    Variant = "radar"
)

type Dataset struct {
	Label           string    `json:"label"`
	Data            []float64 `json:"data"`
	BorderWidth     int       `json:"borderWidth,omitempty"`
	BorderColor     string    `json:"borderColor,omitempty"`
	BackgroundColor string    `json:"backgroundColor,omitempty"`
	Tension         float64   `json:"tension,omitempty"`
	Fill            bool      `json:"fill,omitempty"`
	Stepped         bool      `json:"stepped,omitempty"`
}

type Options struct {
	Responsive bool `json:"responsive,omitempty"`
	Legend     bool `json:"legend,omitempty"`
}

type Data struct {
	Labels   []string  `json:"labels"`
	Datasets []Dataset `json:"datasets"`
}

type Config struct {
	Type        Variant `json:"type"`
	Data        Data    `json:"data"`
	Options     Options `json:"options,omitempty"`
	ShowLegend  bool    `json:"showLegend,omitempty"`
	ShowXAxis   bool    `json:"showXAxis"`
	ShowYAxis   bool    `json:"showYAxis"`
	ShowXLabels bool    `json:"showXLabels"`
	ShowYLabels bool    `json:"showYLabels"`
	ShowXGrid   bool    `json:"showXGrid"`
	ShowYGrid   bool    `json:"showYGrid"`
	Horizontal  bool    `json:"horizontal"`
	Stacked     bool    `json:"stacked"`
}

// Erweiterung des Props um ID und Attributes
type Props struct {
	ID          string
	Variant     Variant
	Data        Data
	Options     Options
	ShowLegend  bool
	ShowXAxis   bool
	ShowYAxis   bool
	ShowXLabels bool
	ShowYLabels bool
	ShowXGrid   bool
	ShowYGrid   bool
	Horizontal  bool
	Stacked     bool
	Class       string
	Attributes  templ.Attributes
}

templ Chart(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = "chart-" + util.RandomID() }}
	}
	{{ canvasId := p.ID + "-canvas" }}
	{{ dataId := p.ID + "-data" }}
	<div
		id={ p.ID }
		class={
			util.TwMerge(
				"chart-container relative",
				p.Class),
		}
		{ p.Attributes... }
	>
		<canvas id={ canvasId } data-chart-id={ dataId }></canvas>
	</div>
	{{
		chartConfig := Config{
			Type:        p.Variant,
			Data:        p.Data,
			Options:     p.Options,
			ShowLegend:  p.ShowLegend,
			ShowXAxis:   p.ShowXAxis,
			ShowYAxis:   p.ShowYAxis,
			ShowXLabels: p.ShowXLabels,
			ShowYLabels: p.ShowYLabels,
			ShowXGrid:   p.ShowXGrid,
			ShowYGrid:   p.ShowYGrid,
			Horizontal:  p.Horizontal,
			Stacked:     p.Stacked,
		}
	}}
	@templ.JSONScript(dataId, chartConfig)
}

templ Script() {
	<!-- Load Chart.js library -->
	<script defer nonce={ templ.GetNonce(ctx) } src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
	<!-- Chart Initialization and HTMX Handling Script -->
	<script nonce={ templ.GetNonce(ctx) }>
			// Ensure chartInstances exists globally and is initialized only once
			window.chartInstances = window.chartInstances || {};

			// Prevent re-initialization of listeners and functions if script runs again
			if (!window.chartScriptInitialized) {
				function getThemeColors() {
					const computedStyle = getComputedStyle(document.documentElement);
					return {
						foreground: computedStyle.getPropertyValue('--foreground').trim() || '#000',
						background: computedStyle.getPropertyValue('--background').trim() || '#fff',
						mutedForeground: computedStyle.getPropertyValue('--muted-foreground').trim() || '#666',
						border: computedStyle.getPropertyValue('--border').trim() || '#ccc'
					};
				}

				function initializeChart(canvas) {
					if (!canvas || !canvas.id || !canvas.hasAttribute('data-chart-id')) {
						return;
					}

					if (window.chartInstances[canvas.id]) {
						cleanupChart(canvas);
					}

					const dataId = canvas.getAttribute('data-chart-id');
					const dataElement = document.getElementById(dataId);
					if (!dataElement) {
						console.error("Chart init error: Could not find data element for canvas:", canvas.id);
						return;
					}

					const colors = getThemeColors();

					try {
						const chartConfig = JSON.parse(dataElement.textContent);
						Chart.defaults.elements.point.radius = 0;
						Chart.defaults.elements.point.hoverRadius = 5;

						const isComplexChart = [
							"pie",
							"doughnut",
							"bar",
							"radar",
						].includes(chartConfig.type);

						const legendOptions = {
							display: chartConfig.showLegend || false,
							labels: { color: colors.foreground },
						};

						const tooltipOptions = {
							backgroundColor: colors.background,
							bodyColor: colors.mutedForeground,
							titleColor: colors.foreground,
							borderColor: colors.border,
							borderWidth: 1,
						};

						const scalesOptions = chartConfig.type === "radar"
							? {
								r: {
									grid: { 
										color: colors.border, 
										display: chartConfig.showYGrid !== false 
									},
									ticks: {
										color: colors.mutedForeground,
										backdropColor: "transparent",
										display: chartConfig.showYLabels !== false,
									},
									angleLines: { 
										color: colors.border, 
										display: chartConfig.showXGrid !== false 
									},
									pointLabels: { 
										color: colors.foreground, 
										font: { size: 12 } 
									},
									border: { 
										display: chartConfig.showYAxis !== false, 
										color: colors.border 
									},
									beginAtZero: true,
								},
							  }
							: {
								x: {
									beginAtZero: true,
									display: chartConfig.showXLabels !== false || 
											 chartConfig.showXGrid !== false || 
											 chartConfig.showXAxis !== false,
									border: { 
										display: chartConfig.showXAxis !== false, 
										color: colors.border 
									},
									ticks: { 
										display: chartConfig.showXLabels !== false, 
										color: colors.mutedForeground 
									},
									grid: { 
										display: chartConfig.showXGrid !== false, 
										color: colors.border 
									},
									stacked: chartConfig.stacked || false,
								},
								y: {
									offset: true,
									beginAtZero: true,
									display: chartConfig.showYLabels !== false || 
											 chartConfig.showYGrid !== false || 
											 chartConfig.showYAxis !== false,
									border: { 
										display: chartConfig.showYAxis !== false, 
										color: colors.border 
									},
									ticks: { 
										display: chartConfig.showYLabels !== false, 
										color: colors.mutedForeground 
									},
									grid: { 
										display: chartConfig.showYGrid !== false, 
										color: colors.border 
									},
									stacked: chartConfig.stacked || false,
								},
							  };

						const finalChartConfig = {
							...chartConfig,
							options: {
								responsive: true,
								maintainAspectRatio: false,
								interaction: {
									intersect: false,
									axis: "xy",
									mode: isComplexChart ? "nearest" : "index",
								},
								indexAxis: chartConfig.horizontal ? "y" : "x",
								plugins: {
									legend: legendOptions,
									tooltip: tooltipOptions,
								},
								scales: scalesOptions,
							},
						};

						const chart = new Chart(canvas, finalChartConfig);
						window.chartInstances[canvas.id] = chart;
					} catch (e) {
						console.error(
							`Error initializing chart ${canvas.id}:`,
							e,
							dataElement ? dataElement.textContent : "No data element found"
						);
					}
				}

				function cleanupChart(canvas) {
					if (!canvas || !canvas.id || !window.chartInstances[canvas.id]) return;
					try {
						window.chartInstances[canvas.id].destroy();
					} catch (e) {
						// Errors during cleanup are often minor, maybe log as warning if needed
					} finally {
						delete window.chartInstances[canvas.id];
					}
				}

				function initializeExistingCharts() {
					document
						.querySelectorAll("canvas[data-chart-id]")
						.forEach((canvas) => {
							if (!window.chartInstances[canvas.id]) {
								initializeChart(canvas);
							}
						});
				}

				function updateAllCharts() {
					document
						.querySelectorAll("canvas[data-chart-id]")
						.forEach((canvas) => {
							if (window.chartInstances[canvas.id]) {
								cleanupChart(canvas);
								initializeChart(canvas);
							} else {
								// If a chart exists in DOM but not in instances, initialize it
								initializeChart(canvas);
							}
						});
				}

				// --- Listener Registrations ---

				// 1. Initial Load Check (using DOMContentLoaded)
				document.addEventListener("DOMContentLoaded", () => {
					function tryInitOnLoad() {
						if (typeof Chart !== "undefined") {
							initializeExistingCharts();
						} else {
							setTimeout(tryInitOnLoad, 100);
						}
					}
					tryInitOnLoad();
				});

				// 2. HTMX Integration (Attached directly to body)
				document.body.addEventListener("htmx:beforeSwap", (event) => {
					const removingElement = event.detail.elt;
					if (removingElement instanceof Element) {
						const canvasesToRemove = removingElement.querySelectorAll(
							"canvas[data-chart-id]"
						);
						canvasesToRemove.forEach(cleanupChart);
						if (removingElement.matches("canvas[data-chart-id]")) {
							cleanupChart(removingElement);
						}
					}
				});

				document.body.addEventListener("htmx:afterSwap", (event) => {
					const newContentTarget = event.detail.target;

					function findAndInitializeCanvases(targetElement) {
						if (!(targetElement instanceof Element)) {
							return;
						}
						const canvasesToAdd = targetElement.querySelectorAll(
							"canvas[data-chart-id]"
						);
						canvasesToAdd.forEach(initializeChart);
						if (targetElement.matches("canvas[data-chart-id]")) {
							initializeChart(targetElement);
						}
					}

					function tryInitializeNewCharts(targetElement, attempt = 1) {
						if (typeof Chart !== "undefined") {
							findAndInitializeCanvases(targetElement);
						} else if (attempt < 10) {
							setTimeout(
								() => tryInitializeNewCharts(targetElement, attempt + 1),
								100
							);
						} else {
							console.error(
								"[Chart Log] Chart.js did not load after multiple retries during htmx:afterSwap. Cannot initialize new charts."
							);
						}
					}

					// Start the process
					tryInitializeNewCharts(newContentTarget);
				});

				// 3. Observer for theme changes
				let themeUpdateTimeout;
				const observer = new MutationObserver(() => {
					clearTimeout(themeUpdateTimeout);
					themeUpdateTimeout = setTimeout(updateAllCharts, 50);
				});
				observer.observe(document.documentElement, {
					attributes: true,
					attributeFilter: ["class", "style"],
				});

				// 4. Optional: Alpine listener for theme changes
				if (typeof Alpine !== "undefined") {
					document.addEventListener("alpine:initialized", () => {
						document.addEventListener("theme-changed", () => {
							updateAllCharts();
						});
					});
				}

				// Set the flag to indicate successful initialization
				window.chartScriptInitialized = true;
			}
		</script>
}
