package popover

import (
	"github.com/axzilla/templui/util"
	"strconv"
)

type Placement string

const (
	PlacementTop         Placement = "top"
	PlacementTopStart    Placement = "top-start"
	PlacementTopEnd      Placement = "top-end"
	PlacementRight       Placement = "right"
	PlacementRightStart  Placement = "right-start"
	PlacementRightEnd    Placement = "right-end"
	PlacementBottom      Placement = "bottom"
	PlacementBottomStart Placement = "bottom-start"
	PlacementBottomEnd   Placement = "bottom-end"
	PlacementLeft        Placement = "left"
	PlacementLeftStart   Placement = "left-start"
	PlacementLeftEnd     Placement = "left-end"
)

type TriggerType string

const (
	TriggerTypeHover TriggerType = "hover"
	TriggerTypeClick TriggerType = "click"
)

type Props struct {
	Class string
}

type TriggerProps struct {
	ID          string
	For         string
	TriggerType TriggerType
}

type ContentProps struct {
	ID               string
	Class            string
	Attributes       templ.Attributes
	Placement        Placement
	Offset           int
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
	HoverDelay       int
	HoverOutDelay    int
}

templ Popover(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ p.Class }>
		{ children... }
	</div>
	<div id="popover-portal-container" class="fixed inset-0 z-[9999] pointer-events-none"></div>
}

templ Trigger(props ...TriggerProps) {
	{{ var p TriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = TriggerTypeClick }}
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		data-popover-trigger
		data-popover-for={ p.For }
		data-popover-type={ string(p.TriggerType) }
	>
		{ children... }
	</span>
}

templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Placement == "" {
		{{ p.Placement = PlacementBottom }}
	}
	if p.Offset == 0 {
		if p.ShowArrow {
			{{ p.Offset = 8 }}
		} else {
			{{ p.Offset = 4 }}
		}
	}
	<div
		id={ p.ID }
		data-popover-id={ p.ID }
		data-popover-placement={ string(p.Placement) }
		data-popover-offset={ strconv.Itoa(p.Offset) }
		data-popover-disable-clickaway={ strconv.FormatBool(p.DisableClickAway) }
		data-popover-disable-esc={ strconv.FormatBool(p.DisableESC) }
		data-popover-show-arrow={ strconv.FormatBool(p.ShowArrow) }
		data-popover-hover-delay={ strconv.Itoa(p.HoverDelay) }
		data-popover-hover-out-delay={ strconv.Itoa(p.HoverOutDelay) }
		class={ util.TwMerge(
			"bg-background rounded-lg border text-sm shadow-lg pointer-events-auto absolute z-[9999]",
			p.Class,
		) }
		style="display: none; top: 0; left: 0;"
		{ p.Attributes... }
	>
		<div class="w-full overflow-hidden">
			{ children... }
		</div>
		if p.ShowArrow {
			<div data-popover-arrow class="absolute h-2.5 w-2.5 rotate-45 bg-background border"></div>
		}
	</div>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script src="https://cdn.jsdelivr.net/npm/@floating-ui/core@1/dist/floating-ui.core.umd.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/@floating-ui/dom@1/dist/floating-ui.dom.umd.min.js"></script>
		<script nonce={ templ.GetNonce(ctx) }>
			// Statemanagement - safely check if already defined
			if (typeof window.popoverState === 'undefined') {
				window.popoverState = new Map();
			}
			
			// Main initialization function - checks if FloatingUI is available
			function initPopoverSystem() {
				if (!window.FloatingUIDOM) {
					setTimeout(initPopoverSystem, 50);
					return;
				}
				
				const { computePosition, autoUpdate, offset, flip, shift, arrow } = window.FloatingUIDOM;
				
				// Helper to find best reference element
				function findReferenceElement(triggerSpan) {
					const children = triggerSpan.children;
					if (children.length === 0) return triggerSpan;
					
					let bestElement = triggerSpan;
					let largestArea = 0;
					
					for (const child of children) {
						const rect = child.getBoundingClientRect();
						const area = rect.width * rect.height;
						if (area > largestArea) {
							largestArea = area;
							bestElement = child;
						}
					}
					
					return bestElement;
				}
				
				// Position popover content using Floating UI
				function updatePosition(content, trigger) {
					const referenceElement = findReferenceElement(trigger);
					const arrowElement = content.querySelector('[data-popover-arrow]');
					const placement = content.dataset.popoverPlacement || 'bottom';
					const offsetValue = parseInt(content.dataset.popoverOffset) || (arrowElement ? 8 : 4);
					
					// Setup middleware stack
					const middleware = [
						offset(offsetValue),
						flip({ padding: 10 }),
						shift({ padding: 10 })
					];
					
					if (arrowElement) {
						middleware.push(arrow({ element: arrowElement, padding: 5 }));
					}
					
					// Compute and apply position
					computePosition(referenceElement, content, {
						placement: placement,
						middleware: middleware
					}).then(({ x, y, placement, middlewareData }) => {
						Object.assign(content.style, {
							left: `${x}px`,
							top: `${y}px`,
						});
						
						// Position arrow if present
						if (arrowElement && middlewareData.arrow) {
							positionArrow(arrowElement, placement, middlewareData.arrow, content);
						}
					});
				}
				
				// Arrow positioning and styling
				function positionArrow(arrowElement, placement, arrowData, content) {
					const { x: arrowX, y: arrowY } = arrowData;
					const staticSide = {
						top: 'bottom',
						right: 'left',
						bottom: 'top',
						left: 'right',
					}[placement.split('-')[0]];
					
					// Position arrow
					Object.assign(arrowElement.style, {
						left: arrowX != null ? `${arrowX}px` : '',
						top: arrowY != null ? `${arrowY}px` : '',
						right: '',
						bottom: '',
						[staticSide]: '-5px',
					});
					
					// Style arrow
					const popoverStyle = window.getComputedStyle(content);
					const popoverBorderColor = popoverStyle.borderColor;
					
					arrowElement.style.backgroundColor = popoverStyle.backgroundColor;
					arrowElement.style.borderTopColor = popoverBorderColor;
					arrowElement.style.borderRightColor = popoverBorderColor;
					arrowElement.style.borderBottomColor = popoverBorderColor;
					arrowElement.style.borderLeftColor = popoverBorderColor;
					
					// Set transparent sides based on placement
					switch (staticSide) {
						case 'top':
							arrowElement.style.borderBottomColor = 'transparent';
							arrowElement.style.borderRightColor = 'transparent';
							break;
						case 'bottom':
							arrowElement.style.borderTopColor = 'transparent';
							arrowElement.style.borderLeftColor = 'transparent';
							break;
						case 'left':
							arrowElement.style.borderTopColor = 'transparent';
							arrowElement.style.borderRightColor = 'transparent';
							break;
						case 'right':
							arrowElement.style.borderBottomColor = 'transparent';
							arrowElement.style.borderLeftColor = 'transparent';
							break;
					}
				}
				
				// Open a popover
				function openPopover(popoverId, trigger, isHover = false) {
					const content = document.getElementById(popoverId);
					if (!content) return;
					
					// Get or create state for this popover
					const state = window.popoverState.get(popoverId) || {
						trigger,
						content,
						cleanup: null,
						isOpen: false,
						hoverState: { enterTimeout: null, leaveTimeout: null },
						eventListeners: {}
					};
					
					// Don't reopen if already open
					if (state.isOpen) return;
					
					// Find portal container
					const portal = document.getElementById('popover-portal-container');
					if (!portal) return;
					
					// Move to portal if needed
					if (content.parentNode !== portal) {
						portal.appendChild(content);
					}
					
					// Display content
					content.style.display = 'block';
					content.classList.remove('popover-animate-out');
					content.classList.add('popover-animate-in');
					
					// Setup position auto-updating
					state.cleanup = autoUpdate(
						findReferenceElement(trigger),
						content,
						() => updatePosition(content, trigger)
					);
					
					// Add closing listeners for click popover
					if (!isHover) {
						// Click away listener
						if (content.dataset.popoverDisableClickaway !== 'true') {
							const clickAwayHandler = (e) => {
								if (!trigger.contains(e.target) && !content.contains(e.target)) {
									closePopover(popoverId);
								}
							};
							
							setTimeout(() => {
								document.addEventListener('click', clickAwayHandler);
								state.eventListeners.clickAway = clickAwayHandler;
							}, 0);
						}
						
						// Escape key listener
						if (content.dataset.popoverDisableEsc !== 'true') {
							const escHandler = (e) => {
								if (e.key === 'Escape') {
									closePopover(popoverId);
								}
							};
							
							document.addEventListener('keydown', escHandler);
							state.eventListeners.esc = escHandler;
						}
					}
					
					state.isOpen = true;
					window.popoverState.set(popoverId, state);
				}
				
				// Close a popover
				function closePopover(popoverId, immediate = false) {
					const state = window.popoverState.get(popoverId);
					if (!state || !state.isOpen) return;
					
					// Stop position updates
					if (state.cleanup) {
						state.cleanup();
						state.cleanup = null;
					}
					
					// Remove event listeners
					if (state.eventListeners.clickAway) {
						document.removeEventListener('click', state.eventListeners.clickAway);
						state.eventListeners.clickAway = null;
					}
					
					if (state.eventListeners.esc) {
						document.removeEventListener('keydown', state.eventListeners.esc);
						state.eventListeners.esc = null;
					}
					
					const content = state.content;
					
					function hideContent() {
						content.style.display = 'none';
						content.classList.remove('popover-animate-in', 'popover-animate-out');
					}
					
					if (immediate) {
						hideContent();
					} else {
						content.classList.remove('popover-animate-in');
						content.classList.add('popover-animate-out');
						setTimeout(hideContent, 150);
					}
					
					state.isOpen = false;
					window.popoverState.set(popoverId, state);
				}
				
				// Setup hover events
				function setupHoverEvents(trigger, popoverId) {
					const content = document.getElementById(popoverId);
					if (!content) return;
					
					// Get or create state
					const state = window.popoverState.get(popoverId) || {
						trigger,
						content,
						cleanup: null,
						isOpen: false,
						hoverState: { enterTimeout: null, leaveTimeout: null },
						eventListeners: {}
					};
					
					// Trigger mouseenter - delay showing
					trigger.addEventListener('mouseenter', () => {
						clearTimeout(state.hoverState.leaveTimeout);
						
						const hoverDelay = parseInt(content.dataset.popoverHoverDelay) || 100;
						state.hoverState.enterTimeout = setTimeout(() => {
							openPopover(popoverId, trigger, true);
						}, hoverDelay);
					});
					
					// Trigger mouseleave - delay hiding
					trigger.addEventListener('mouseleave', (e) => {
						clearTimeout(state.hoverState.enterTimeout);
						
						const hoverOutDelay = parseInt(content.dataset.popoverHoverOutDelay) || 200;
						state.hoverState.leaveTimeout = setTimeout(() => {
							// Only close if mouse didn't enter the content
							if (!content.contains(e.relatedTarget)) {
								closePopover(popoverId);
							}
						}, hoverOutDelay);
					});
					
					// Content mouseenter - cancel hiding
					content.addEventListener('mouseenter', () => {
						clearTimeout(state.hoverState.leaveTimeout);
					});
					
					// Content mouseleave - delay hiding
					content.addEventListener('mouseleave', (e) => {
						const hoverOutDelay = parseInt(content.dataset.popoverHoverOutDelay) || 200;
						state.hoverState.leaveTimeout = setTimeout(() => {
							// Only close if mouse didn't enter the trigger
							if (!trigger.contains(e.relatedTarget)) {
								closePopover(popoverId);
							}
						}, hoverOutDelay);
					});
					
					window.popoverState.set(popoverId, state);
				}
				
				// Initialize a trigger
				function initTrigger(trigger) {
					const popoverId = trigger.dataset.popoverFor;
					if (!popoverId) return;
					
					const content = document.getElementById(popoverId);
					if (!content) return;
					
					const triggerType = trigger.dataset.popoverType || 'click';
					
					// Setup appropriate event listeners based on trigger type
					if (triggerType === 'click') {
						trigger.addEventListener('click', () => {
							const state = window.popoverState.get(popoverId);
							if (state && state.isOpen) {
								closePopover(popoverId);
							} else {
								openPopover(popoverId, trigger);
							}
						});
					} else if (triggerType === 'hover') {
						setupHoverEvents(trigger, popoverId);
					}
				}
				
				// Add animation styles if not already present
				function addAnimationStyles() {
					if (document.getElementById('popover-animations')) return;
					
					const style = document.createElement('style');
					style.id = 'popover-animations';
					style.textContent = `
						@keyframes popover-in { 0% { opacity: 0; transform: scale(0.95); } 100% { opacity: 1; transform: scale(1); } }
						@keyframes popover-out { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0.95); } }
						.popover-animate-in { animation: popover-in 0.15s cubic-bezier(0.16, 1, 0.3, 1); }
						.popover-animate-out { animation: popover-out 0.1s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
					`;
					document.head.appendChild(style);
				}
				
				// Clean up all popovers in a given element before removal
				function cleanupPopovers(element) {
					// Find triggers being removed
					const triggers = element.querySelectorAll('[data-popover-trigger]');
					for (const trigger of triggers) {
						const popoverId = trigger.dataset.popoverFor;
						if (popoverId) {
							closePopover(popoverId, true);
						}
					}
					
					// Check if element itself is a trigger
					if (element.matches && element.matches('[data-popover-trigger]')) {
						const popoverId = element.dataset.popoverFor;
						if (popoverId) {
							closePopover(popoverId, true);
						}
					}
				}
				
				// Initialize all popovers in a given root element
				function initAllComponents(root = document) {
					for (const trigger of root.querySelectorAll('[data-popover-trigger]')) {
						initTrigger(trigger);
					}
					
					// Also check if root itself is a trigger
					if (root.matches && root.matches('[data-popover-trigger]')) {
						initTrigger(root);
					}
				}
				
				// Add animation styles
				addAnimationStyles();
				
				// HTMX integration
				document.body.addEventListener('htmx:beforeSwap', (evt) => {
					const target = evt.detail.target;
					if (target) {
						cleanupPopovers(target);
					}
				});
				
				document.body.addEventListener('htmx:afterSwap', (evt) => {
					if (evt.target) {
						setTimeout(() => initAllComponents(evt.target), 0);
					}
				});
				
				// Initial setup
				initAllComponents();
			}
			
			// Start initialization when DOM is ready
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initPopoverSystem);
			} else {
				initPopoverSystem();
			}
		</script>
	}
}
