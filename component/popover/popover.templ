package popover

import (
	"github.com/axzilla/templui/util"
	"strconv"
)

// Floating UI Placement (https://floating-ui.com/docs/computePosition#placement)
type Placement string

const (
	PlacementTop         Placement = "top"
	PlacementTopStart    Placement = "top-start"
	PlacementTopEnd      Placement = "top-end"
	PlacementRight       Placement = "right"
	PlacementRightStart  Placement = "right-start"
	PlacementRightEnd    Placement = "right-end"
	PlacementBottom      Placement = "bottom"
	PlacementBottomStart Placement = "bottom-start"
	PlacementBottomEnd   Placement = "bottom-end"
	PlacementLeft        Placement = "left"
	PlacementLeftStart   Placement = "left-start"
	PlacementLeftEnd     Placement = "left-end"
)

type TriggerType string

const (
	TriggerTypeHover TriggerType = "hover"
	TriggerTypeClick TriggerType = "click"
)

type Props struct {
	Class string
}

// Trigger Props - Minimal set needed to link trigger and content
type TriggerProps struct {
	ID          string // Optional ID for the trigger itself
	For         string // REQUIRED: Corresponds to the ID of the Content component
	TriggerType TriggerType
}

// Content Props - Includes Floating UI options and content styling
type ContentProps struct {
	ID               string // REQUIRED: Must match TriggerProps.For
	Class            string
	Attributes       templ.Attributes
	Placement        Placement // Use Floating UI's placement
	Offset           int       // Optional offset value (default: 8 if arrow, 4 otherwise)
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
	HoverDelay       int // Delay for showing on hover
	HoverOutDelay    int // Delay for hiding on hover
}

// --- Components ---

// Popover Wrapper and Portal Container
templ Popover(props ...Props) {
	@Script()
	// Ensure script is included once
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ util.TwMerge("relative inline-block", p.Class) }>
		{ children... }
		// Expects Trigger and Content as siblings
	</div>
	// Portal container - Floating UI will place the content here
	<div id="popover-portal-container" class="fixed inset-0 z-[9999] pointer-events-none"></div>
}

// Popover Trigger
templ Trigger(props ...TriggerProps) {
	{{ var p TriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = TriggerTypeClick }}
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		data-popover-trigger
		data-popover-for={ p.For }
		data-popover-type={ string(p.TriggerType) }
	>
		{ children... }
	</span>
}

// Popover Content (renders the div directly, hidden initially)
templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Placement == "" {
		{{ p.Placement = PlacementBottom }}
	}
	if p.Offset == 0 {
		if p.ShowArrow {
			{{ p.Offset = 8 }}
		} else {
			{{ p.Offset = 4 }}
		}
	}
	<div
		id={ p.ID }
		data-popover-id={ p.ID }
		data-popover-placement={ string(p.Placement) }
		data-popover-offset={ strconv.Itoa(p.Offset) }
		data-popover-disable-clickaway={ strconv.FormatBool(p.DisableClickAway) }
		data-popover-disable-esc={ strconv.FormatBool(p.DisableESC) }
		data-popover-show-arrow={ strconv.FormatBool(p.ShowArrow) }
		data-popover-hover-delay={ strconv.Itoa(p.HoverDelay) }
		data-popover-hover-out-delay={ strconv.Itoa(p.HoverOutDelay) }
		class={ util.TwMerge(
			"bg-background rounded-lg border text-sm shadow-lg pointer-events-auto absolute z-[9999]",
			p.Class,
		) }
		style="display: none; top: 0; left: 0;"
		{ p.Attributes... }
	>
		<div class="w-full overflow-hidden">
			{ children... }
			// The actual content goes here
		</div>
		if p.ShowArrow {
			// Arrow element - positioned by Floating UI middleware
			<div data-popover-arrow class="absolute h-2.5 w-2.5 rotate-45 bg-background border"></div>
		}
	</div>
}

// --- Script ---
var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer src="https://cdn.jsdelivr.net/npm/@floating-ui/core@1/dist/floating-ui.core.umd.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/@floating-ui/dom@1/dist/floating-ui.dom.umd.min.js"></script>
		<script defer nonce={ templ.GetNonce(ctx) }>
			(() => {
				// Wait for Floating UI and DOM content before initializing
				const checkFloatingUI = setInterval(() => {
					if (window.FloatingUIDOM && document.readyState !== 'loading') {
						clearInterval(checkFloatingUI);
						initializePopovers();
					}
				}, 50);

				function initializePopovers() {
					const { computePosition, autoUpdate, offset, flip, shift, arrow } = window.FloatingUIDOM;

					// Map to store active popover state and cleanup functions from autoUpdate
					const activePopovers = new Map(); // Map<popoverId, { cleanup: Function | null, content: HTMLElement, trigger: HTMLElement, hoverState: object } >

					// --- Helper: Find the best element within the trigger span for positioning ---
					function findReferenceElement(triggerSpan) {
						let triggerElement = triggerSpan;
						let largestArea = 0;
						const children = triggerSpan.children;
						for (let i = 0; i < children.length; i++) {
							const child = children[i];
							const rect = child.getBoundingClientRect();
							const area = rect.width * rect.height;
							if (area > largestArea) {
								largestArea = area;
								triggerElement = child;
							}
						}
						return triggerElement;
					}

					// --- Setup individual popover logic ---
					function setupPopover(trigger) {
						const popoverId = trigger.dataset.popoverFor;
						if (!popoverId || activePopovers.has(popoverId)) return; // Avoid double initialization

						const content = document.getElementById(popoverId);
						if (!content) {
							console.error(`Popover content element with ID '${popoverId}' not found.`);
							return;
						}

						const portalContainer = document.getElementById('popover-portal-container');
						if (!portalContainer) {
							console.error("Popover portal container 'popover-portal-container' not found!");
							return;
						}

						activePopovers.set(popoverId, {
							cleanup: null,
							content: content,
							trigger: trigger,
							hoverState: { hoverTimeout: null, leaveTimeout: null }
						});

						// --- Positioning Logic (using Floating UI) ---
						function updatePosition() {
							const referenceElement = findReferenceElement(trigger);
							const arrowElement = content.querySelector('[data-popover-arrow]');
							const placement = content.dataset.popoverPlacement || 'bottom';
							const offsetValue = parseInt(content.dataset.popoverOffset) || (arrowElement ? 8 : 4);

							// Middleware order matters: offset first, then flip/shift, then arrow.
							const middleware = [
								offset(offsetValue),
								flip({ padding: 10 }),
								shift({ padding: 10 })
							];
							if (arrowElement) {
								middleware.push(arrow({ element: arrowElement, padding: 5 }));
							}

							computePosition(referenceElement, content, {
								placement: placement,
								middleware: middleware
							}).then(({ x, y, placement, middlewareData }) => {
								Object.assign(content.style, {
									left: `${x}px`,
									top: `${y}px`,
								});

								// Arrow positioning
								if (middlewareData.arrow && arrowElement) {
									const { x: arrowX, y: arrowY } = middlewareData.arrow;
									const staticSide = {
										top: 'bottom',
										right: 'left',
										bottom: 'top',
										left: 'right',
									}[placement.split('-')[0]];

									Object.assign(arrowElement.style, {
										left: arrowX != null ? `${arrowX}px` : '',
										top: arrowY != null ? `${arrowY}px` : '',
										right: '',
										bottom: '',
										[staticSide]: '-5px', // Position arrow slightly outside
									});

									// Simplified Arrow Border Styling
									const popoverStyle = window.getComputedStyle(content);
									const popoverBorderColor = popoverStyle.borderColor;
									arrowElement.style.backgroundColor = popoverStyle.backgroundColor;
									arrowElement.style.borderTopColor = popoverBorderColor;
									arrowElement.style.borderRightColor = popoverBorderColor;
									arrowElement.style.borderBottomColor = popoverBorderColor;
									arrowElement.style.borderLeftColor = popoverBorderColor;

									switch (staticSide) {
										case 'top':
											arrowElement.style.borderBottomColor = 'transparent';
											arrowElement.style.borderRightColor = 'transparent';
											break;
										case 'bottom':
											arrowElement.style.borderTopColor = 'transparent';
											arrowElement.style.borderLeftColor = 'transparent';
											break;
										case 'left':
											arrowElement.style.borderTopColor = 'transparent';
											arrowElement.style.borderRightColor = 'transparent';
											break;
										case 'right':
											arrowElement.style.borderBottomColor = 'transparent';
											arrowElement.style.borderLeftColor = 'transparent';
											break;
									}
								}
							});
						}

						// --- Open Popover ---
						function openPopover(isHover = false) {
							const popoverData = activePopovers.get(popoverId);
							if (!popoverData || popoverData.cleanup) return; // Already open or not found

							portalContainer.appendChild(content);
							content.style.display = 'block';
							content.classList.remove('popover-animate-out');
							content.classList.add('popover-animate-in');

							// Start auto-updating position (returns a cleanup function)
							popoverData.cleanup = autoUpdate(
								findReferenceElement(trigger),
								content,
								updatePosition
							);
							activePopovers.set(popoverId, popoverData);

							// Add closing listeners for click trigger
							if (!isHover) {
								if (content.dataset.popoverDisableClickaway !== 'true') {
									popoverData.clickAwayListener = (e) => {
										if (!trigger.contains(e.target) && !content.contains(e.target)) {
											closePopover();
										}
									};
									// Timeout needed to prevent the click event that opened the popover from immediately closing it.
									setTimeout(() => document.addEventListener('click', popoverData.clickAwayListener), 0);
								}
								if (content.dataset.popoverDisableEsc !== 'true') {
									popoverData.escListener = (e) => {
										if (e.key === 'Escape') {
											closePopover();
										}
									};
									document.addEventListener('keydown', popoverData.escListener);
								}
							}
						}

						// --- Close Popover ---
						function closePopover(immediate = false) {
							const popoverData = activePopovers.get(popoverId);
							if (!popoverData || !popoverData.cleanup) return; // Already closed or not found

							// Stop auto-updating position
							popoverData.cleanup();
							popoverData.cleanup = null;

							// Remove closing listeners
							if (popoverData.clickAwayListener) {
								document.removeEventListener('click', popoverData.clickAwayListener);
								popoverData.clickAwayListener = null;
							}
							if (popoverData.escListener) {
								document.removeEventListener('keydown', popoverData.escListener);
								popoverData.escListener = null;
							}

							const cleanupDOM = () => {
								content.style.display = 'none';
								content.classList.remove('popover-animate-in', 'popover-animate-out');
							};

							if (immediate) {
								cleanupDOM();
							} else {
								content.classList.remove('popover-animate-in');
								content.classList.add('popover-animate-out');
								setTimeout(cleanupDOM, 150); // Delay matches animation duration
							}
						}

						// --- Attach Trigger Event Listeners ---
						const triggerType = trigger.dataset.popoverType || 'click';

						if (triggerType === 'click') {
							trigger.addEventListener('click', (e) => {
								const popoverData = activePopovers.get(popoverId);
								if (popoverData && popoverData.cleanup) {
									closePopover();
								} else {
									openPopover();
								}
							});
						} else if (triggerType === 'hover') {
							const popoverData = activePopovers.get(popoverId);

							trigger.addEventListener('mouseenter', () => {
								clearTimeout(popoverData.hoverState.leaveTimeout);
								const hoverDelay = parseInt(content.dataset.popoverHoverDelay) || 100;
								popoverData.hoverState.hoverTimeout = setTimeout(() => openPopover(true), hoverDelay);
							});

							trigger.addEventListener('mouseleave', (e) => {
								clearTimeout(popoverData.hoverState.hoverTimeout);
								const hoverOutDelay = parseInt(content.dataset.popoverHoverOutDelay) || 200;
								popoverData.hoverState.leaveTimeout = setTimeout(() => {
									// Only close if mouse didn't enter the popover content itself
									const relatedTarget = e.relatedTarget;
									if (!content.contains(relatedTarget)) {
										closePopover();
									}
								}, hoverOutDelay);
							});

							// Keep open when hovering over content
							content.addEventListener('mouseenter', () => {
								clearTimeout(popoverData.hoverState.leaveTimeout);
							});
							content.addEventListener('mouseleave', (e) => {
								const hoverOutDelay = parseInt(content.dataset.popoverHoverOutDelay) || 200;
								popoverData.hoverState.leaveTimeout = setTimeout(() => {
									// Only close if mouse didn't enter the trigger itself
									const relatedTarget = e.relatedTarget;
									if (!trigger.contains(relatedTarget)) {
										closePopover();
									}
								}, hoverOutDelay);
							});
						}
					} // End setupPopover

					// --- Initial Setup: Find and initialize all triggers on the page ---
					document.querySelectorAll('[data-popover-trigger]').forEach(setupPopover);

					// --- HTMX Integration ---
					document.body.addEventListener('htmx:afterSwap', (event) => {
						const targetElement = event.detail.target || event.target;
						if (targetElement && targetElement.querySelectorAll) {
							// Find and initialize any new triggers within the swapped content
							targetElement.querySelectorAll('[data-popover-trigger]').forEach(setupPopover);
							// Also initialize if the swapped element itself is a trigger
							if (targetElement.matches('[data-popover-trigger]')) {
								setupPopover(targetElement);
							}
						}
					});

					document.body.addEventListener('htmx:beforeSwap', (event) => {
						let containerToRemove = event.detail.target || event.detail.elt;
						if (containerToRemove && containerToRemove.querySelectorAll) {
							// Close popovers whose trigger is *inside* the element being removed
							containerToRemove.querySelectorAll('[data-popover-trigger]').forEach(trigger => {
								const popoverId = trigger.dataset.popoverFor;
								if (popoverId && activePopovers.has(popoverId)) {
									const popoverData = activePopovers.get(popoverId);
									if(popoverData.cleanup) closePopover.call({popoverId: popoverId}, true); // Close immediately
									activePopovers.delete(popoverId);
								}
							});
							// Close popover if the element being removed *is* a trigger itself
							if (containerToRemove.matches('[data-popover-trigger]')) {
								const popoverId = containerToRemove.dataset.popoverFor;
								if (popoverId && activePopovers.has(popoverId)) {
									const popoverData = activePopovers.get(popoverId);
									if(popoverData.cleanup) closePopover.call({popoverId: popoverId}, true);
									activePopovers.delete(popoverId);
								}
							}
							// Note: Checking for removed *content* elements directly is less reliable
							// as they live in the portal. Relying on trigger removal is safer.
						}
					});

					// Inject CSS Animations
					const style = document.createElement('style');
					style.textContent = `
						@keyframes popover-in { 0% { opacity: 0; transform: scale(0.95); } 100% { opacity: 1; transform: scale(1); } }
						@keyframes popover-out { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0.95); } }
						.popover-animate-in { animation: popover-in 0.15s cubic-bezier(0.16, 1, 0.3, 1); }
						.popover-animate-out { animation: popover-out 0.1s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
					`;
					document.head.appendChild(style);
				} // End initializePopovers

			})();
		</script>
	}
}
