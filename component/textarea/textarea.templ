package textarea

import (
	"github.com/axzilla/templui/util"
	"strconv"
)

type Props struct {
	ID          string
	Class       string
	Attributes  templ.Attributes
	Name        string
	Value       string
	Placeholder string
	Rows        int
	AutoResize  bool
	Disabled    bool
	Required    bool
}

templ Textarea(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = util.RandomID() }}
	}
	<textarea
		id={ p.ID }
		data-textarea
		if p.Name != "" {
			name={ p.Name }
		}
		if p.Placeholder != "" {
			placeholder={ p.Placeholder }
		}
		if p.Rows > 0 {
			rows={ strconv.Itoa(p.Rows) }
		}
		disabled?={ p.Disabled }
		required?={ p.Required }
		if p.AutoResize {
			data-auto-resize="true"
		}
		class={
			util.TwMerge(
				"flex w-full px-3 py-2",
				"min-h-[80px]", // Default min-height (adjust if needed)
				"rounded-md border border-input bg-background text-sm",
				"ring-offset-background",
				"placeholder:text-muted-foreground",
				"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
				"disabled:cursor-not-allowed disabled:opacity-50",
				// Add overflow-hidden only if auto-resizing to prevent scrollbar flicker
				util.If(p.AutoResize, "overflow-hidden resize-none"),
				p.Class,
			),
		}
		{ p.Attributes... }
	>{ p.Value }</textarea>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			function initializeTextarea(textarea) {
				if (textarea.dataset.textareaInitialized === 'true') {
					return; // Already initialized
				}
				textarea.dataset.textareaInitialized = 'true';

				const autoResize = textarea.dataset.autoResize === 'true';
				let handleInput = null; // Store listener reference for cleanup

				if (autoResize) {
					// Calculate initial min-height based on CSS or rows attribute
					const computedStyle = window.getComputedStyle(textarea);
					const initialMinHeight = computedStyle.minHeight;
					// Store it for resetting
					textarea.dataset.initialMinHeight = initialMinHeight;

					const resizeTextarea = () => {
						// Reset height to recalculate scrollHeight correctly
						textarea.style.height = textarea.dataset.initialMinHeight || 'auto'; 
						// Set height to scrollHeight to fit content
						textarea.style.height = `${textarea.scrollHeight}px`;
					};

					handleInput = resizeTextarea; // Assign function to variable

					// --- Initialization ---
					resizeTextarea(); // Initial resize on load
					textarea.addEventListener('input', handleInput);

					// Store cleanup function
					textarea._textareaCleanup = () => {
						if (handleInput) {
							textarea.removeEventListener('input', handleInput);
						}
					};
				} else {
					// No cleanup needed if not auto-resizing initially
					textarea._textareaCleanup = () => {}; 
				}
			}

			// --- Global Initialization Triggers ---
			function initializeAllTextareas() {
				document.querySelectorAll('textarea[data-textarea]:not([data-textarea-initialized])').forEach(initializeTextarea);
			}

			// 1. Initial page load
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeAllTextareas);
			} else {
				initializeAllTextareas(); // Already loaded
			}

			// 2. After HTMX swaps
			document.body.addEventListener('htmx:afterSwap', function(event) {
				const targetElement = event.target instanceof Element ? event.target : null;
				if (targetElement) {
					// Check if the swapped element itself is a textarea
					if (targetElement.matches('textarea[data-textarea]:not([data-textarea-initialized])')) {
						initializeTextarea(targetElement);
					}
					// Check for textareas within the swapped content
					targetElement.querySelectorAll('textarea[data-textarea]:not([data-textarea-initialized])').forEach(initializeTextarea);
				}
			});

			// 3. Cleanup before HTMX removes elements
			document.body.addEventListener('htmx:beforeCleanup', (event) => {
				let containerToRemove = event.detail.target || event.detail.elt;
				if (containerToRemove && containerToRemove.querySelectorAll) {
					// Cleanup textareas within the container
					containerToRemove.querySelectorAll('textarea[data-textarea][data-textarea-initialized]').forEach(textarea => {
						if (typeof textarea._textareaCleanup === 'function') {
							textarea._textareaCleanup();
							delete textarea._textareaCleanup;
							textarea.removeAttribute('data-textarea-initialized');
						}
					});
					// Cleanup if the container itself is a textarea
					if (containerToRemove.matches('textarea[data-textarea][data-textarea-initialized]')) {
						if (typeof containerToRemove._textareaCleanup === 'function') {
							containerToRemove._textareaCleanup();
							delete containerToRemove._textareaCleanup;
							containerToRemove.removeAttribute('data-textarea-initialized');
						}
					}
				}
			});
		</script>
	}
}
