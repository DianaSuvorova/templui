package components

import (
	"github.com/axzilla/templui/utils"
	"strconv"
)

type PopoverPosition string

const (
	PopoverTop         PopoverPosition = "top"
	PopoverTopStart    PopoverPosition = "top-start"
	PopoverTopEnd      PopoverPosition = "top-end"
	PopoverRight       PopoverPosition = "right"
	PopoverRightStart  PopoverPosition = "right-start"
	PopoverRightEnd    PopoverPosition = "right-end"
	PopoverBottom      PopoverPosition = "bottom"
	PopoverBottomStart PopoverPosition = "bottom-start"
	PopoverBottomEnd   PopoverPosition = "bottom-end"
	PopoverLeft        PopoverPosition = "left"
	PopoverLeftStart   PopoverPosition = "left-start"
	PopoverLeftEnd     PopoverPosition = "left-end"
)

type PopoverTriggerType string

const (
	PopoverTriggerTypeHover PopoverTriggerType = "hover"
	PopoverTriggerTypeClick PopoverTriggerType = "click"
)

type PopoverProps struct {
	Class string
}

type PopoverTriggerProps struct {
	ID          string
	TriggerType PopoverTriggerType
}

type PopoverContentProps struct {
	ID               string
	Class            string
	Attributes       templ.Attributes
	Position         PopoverPosition
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
}

templ popoverPortalContainer() {
	<div
		id="popover-portal-container"
		class="fixed inset-0 z-[9999] pointer-events-none"
	></div>
}

templ PopoverTrigger(props ...PopoverTriggerProps) {
	{{ var p PopoverTriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = PopoverTriggerTypeClick }}
	}
	<span
		data-popover-trigger
		data-popover-id={ p.ID }
		data-popover-type={ string(p.TriggerType) }
	>
		{ children... }
	</span>
}

templ Popover(props ...PopoverProps) {
	{{ var p PopoverProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ utils.TwMerge("relative inline-block", p.Class) }>
		{ children... }
	</div>
	@popoverPortalContainer()
}

templ PopoverContent(props ...PopoverContentProps) {
	{{ var p PopoverContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Position == "" {
		{{ p.Position = PopoverBottom }}
	}
	<div
		data-popover-content
		data-popover-id={ p.ID }
		data-popover-position={ string(p.Position) }
		data-popover-disable-clickaway={ strconv.FormatBool(p.DisableClickAway) }
		data-popover-disable-esc={ strconv.FormatBool(p.DisableESC) }
		class={
			utils.TwMerge(
				"bg-background rounded-lg border text-sm shadow-lg hidden pointer-events-auto absolute z-[9999]",
				p.Class,
			),
		}
		{ p.Attributes... }
	>
		<div class="w-full overflow-hidden">
			{ children... }
		</div>
		if p.ShowArrow {
			<div
				class={
					utils.TwMerge(
						"absolute h-2.5 w-2.5 rotate-45 bg-background",
						popoverArrowClass(p.Position),
					),
				}
			></div>
		}
	</div>
}

func popoverArrowClass(side PopoverPosition) string {
	switch side {
	case PopoverTop:
		return "bottom-[-5px] left-1/2 -translate-x-1/2 border-b border-r"
	case PopoverTopStart:
		return "bottom-[-5px] left-4 border-b border-r"
	case PopoverTopEnd:
		return "bottom-[-5px] right-4 border-b border-r"
	case PopoverRight:
		return "left-[-5px] top-1/2 -translate-y-1/2 border-b border-l"
	case PopoverRightStart:
		return "left-[-5px] top-2 border-b border-l"
	case PopoverRightEnd:
		return "left-[-5px] bottom-2 border-b border-l"
	case PopoverBottom:
		return "top-[-5px] left-1/2 -translate-x-1/2 border-t border-l"
	case PopoverBottomStart:
		return "top-[-5px] left-4 border-t border-l"
	case PopoverBottomEnd:
		return "top-[-5px] right-4 border-t border-l"
	case PopoverLeft:
		return "right-[-5px] top-1/2 -translate-y-1/2 border-t border-r"
	case PopoverLeftStart:
		return "right-[-5px] top-2 border-t border-r"
	case PopoverLeftEnd:
		return "right-[-5px] bottom-2 border-t border-r"
	default:
		return "top-[-5px] left-1/2 -translate-x-1/2 border-t border-l"
	}
}

templ PopoverScript() {
	<script defer nonce={ templ.GetNonce(ctx) }>
        document.addEventListener('DOMContentLoaded', () => {
            const portalContainer = document.getElementById('popover-portal-container');
            if (!portalContainer) return;
            
            const triggers = document.querySelectorAll('[data-popover-trigger]');
            const contents = document.querySelectorAll('[data-popover-content]');

            contents.forEach(content => {
                portalContainer.appendChild(content);
            });

            const positionPopover = (trigger, content) => {
                // Wir müssen das tatsächliche Element finden, auf das sich der Popover bezieht
                // Das kann der Trigger selbst sein oder ein Kind-Element
                // Wir analysieren die Boundingbox und nehmen das größte Element
                let triggerElement = trigger;
                let largestArea = 0;
                
                // Prüfe alle direkten Kinder des Triggers
                const children = trigger.children;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    const rect = child.getBoundingClientRect();
                    const area = rect.width * rect.height;
                    
                    // Wenn das Kind eine größere Fläche hat, ist es wahrscheinlich das sichtbare Element
                    if (area > largestArea) {
                        largestArea = area;
                        triggerElement = child;
                    }
                }
                
                const triggerRect = triggerElement.getBoundingClientRect();
                const contentRect = content.getBoundingClientRect();
                const margin = 8;
                const scrollY = window.scrollY || window.pageYOffset;
                const scrollX = window.scrollX || window.pageXOffset;

                let top, left;
                const position = content.dataset.popoverPosition || 'bottom';

                // Get element heights
                const triggerHeight = triggerRect.height;
                const contentHeight = contentRect.height;
                
                // Definiere Ankerpunkte
                const triggerTop = triggerRect.top + scrollY;
                const triggerBottom = triggerRect.bottom + scrollY;
                const triggerLeft = triggerRect.left + scrollX;
                const triggerRight = triggerRect.right + scrollX;
                
                console.log(`Selected Trigger Element:`, triggerElement);
                console.log(`Trigger: top=${triggerTop}, bottom=${triggerBottom}, height=${triggerHeight}`);
                console.log(`Content: height=${contentHeight}`);

                switch (position) {
                    case 'top':
                        top = triggerTop - contentHeight - margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                        break;
                    case 'top-start':
                        top = triggerTop - contentHeight - margin;
                        left = triggerLeft;
                        break;
                    case 'top-end':
                        top = triggerTop - contentHeight - margin;
                        left = triggerRight - contentRect.width;
                        break;
                    case 'right':
                        top = triggerTop + (triggerHeight / 2) - (contentHeight / 2);
                        left = triggerRight + margin;
                        break;
                    case 'right-start':
                        // Rechts vom Trigger, oben ausgerichtet
                        top = triggerTop;
                        left = triggerRight + margin;
                        break;
                    case 'right-end':
                        // Rechts vom Trigger, unten ausgerichtet
                        top = triggerBottom - contentHeight;
                        left = triggerRight + margin;
                        break;
                    case 'bottom':
                        top = triggerBottom + margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                        break;
                    case 'bottom-start':
                        top = triggerBottom + margin;
                        left = triggerLeft;
                        break;
                    case 'bottom-end':
                        top = triggerBottom + margin;
                        left = triggerRight - contentRect.width;
                        break;
                    case 'left':
                        top = triggerTop + (triggerHeight / 2) - (contentHeight / 2);
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    case 'left-start':
                        // Links vom Trigger, oben ausgerichtet
                        top = triggerTop;
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    case 'left-end':
                        // Links vom Trigger, unten ausgerichtet
                        top = triggerBottom - contentHeight;
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    default:
                        top = triggerBottom + margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                }

                content.style.top = `${top}px`;
                content.style.left = `${left}px`;
                
                console.log(`Positioning ${position}: top=${top}, left=${left}`);
            };

            triggers.forEach(trigger => {
                const popoverId = trigger.dataset.popoverId;
                const content = document.querySelector(`[data-popover-content][data-popover-id="${popoverId}"]`);
                if (!content) return;

                const triggerType = trigger.dataset.popoverType;

                if (triggerType === 'click') {
                    trigger.addEventListener('click', () => {
                        const isOpen = content.classList.contains('hidden');
                        content.classList.toggle('hidden', !isOpen);
                        if (isOpen) positionPopover(trigger, content);
                    });

                    if (content.dataset.popoverDisableClickaway !== 'true') {
                        document.addEventListener('click', (e) => {
                            if (!content.classList.contains('hidden') && 
                                !trigger.contains(e.target) && 
                                !content.contains(e.target)) {
                                content.classList.add('hidden');
                            }
                        });
                    }

                    if (content.dataset.popoverDisableEsc !== 'true') {
                        document.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape' && !content.classList.contains('hidden')) {
                                content.classList.add('hidden');
                            }
                        });
                    }
                } else if (triggerType === 'hover') {
                    trigger.addEventListener('mouseenter', () => {
                        content.classList.remove('hidden');
                        positionPopover(trigger, content);
                    });
                    trigger.addEventListener('mouseleave', () => {
                        content.classList.add('hidden');
                    });
                }
            });

            // Global scroll and resize event for all popovers
            window.addEventListener('scroll', () => {
                triggers.forEach(trigger => {
                    const popoverId = trigger.dataset.popoverId;
                    const content = document.querySelector(`[data-popover-content][data-popover-id="${popoverId}"]`);
                    if (!content || content.classList.contains('hidden')) return;
                    
                    positionPopover(trigger, content);
                });
            }, { passive: true }); // Using passive for better scroll performance

            // Identify and attach scroll events to all scrollable parents
            triggers.forEach(trigger => {
                let element = trigger;
                const scrollableParents = [];
                
                // Find all scrollable parents
                while (element) {
                    if (element.scrollHeight > element.clientHeight) {
                        scrollableParents.push(element);
                    }
                    element = element.parentElement;
                }
                
                // Attach scroll event to each scrollable parent
                scrollableParents.forEach(scrollParent => {
                    scrollParent.addEventListener('scroll', () => {
                        const popoverId = trigger.dataset.popoverId;
                        const content = document.querySelector(`[data-popover-content][data-popover-id="${popoverId}"]`);
                        if (!content || content.classList.contains('hidden')) return;
                        
                        positionPopover(trigger, content);
                    }, { passive: true });
                });
            });

            window.addEventListener('resize', () => {
                triggers.forEach(trigger => {
                    const popoverId = trigger.dataset.popoverId;
                    const content = document.querySelector(`[data-popover-content][data-popover-id="${popoverId}"]`);
                    if (!content || content.classList.contains('hidden')) return;
                    
                    positionPopover(trigger, content);
                });
            });
        });
    </script>
}
