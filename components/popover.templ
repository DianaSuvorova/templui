package components

import (
	"github.com/axzilla/templui/utils"
	"strconv"
)

type PopoverPosition string

const (
	PopoverTop         PopoverPosition = "top"
	PopoverTopStart    PopoverPosition = "top-start"
	PopoverTopEnd      PopoverPosition = "top-end"
	PopoverRight       PopoverPosition = "right"
	PopoverRightStart  PopoverPosition = "right-start"
	PopoverRightEnd    PopoverPosition = "right-end"
	PopoverBottom      PopoverPosition = "bottom"
	PopoverBottomStart PopoverPosition = "bottom-start"
	PopoverBottomEnd   PopoverPosition = "bottom-end"
	PopoverLeft        PopoverPosition = "left"
	PopoverLeftStart   PopoverPosition = "left-start"
	PopoverLeftEnd     PopoverPosition = "left-end"
)

type PopoverTriggerType string

const (
	PopoverTriggerTypeHover PopoverTriggerType = "hover"
	PopoverTriggerTypeClick PopoverTriggerType = "click"
)

type PopoverProps struct {
	Class string
}

type PopoverTriggerProps struct {
	ID          string
	TriggerType PopoverTriggerType
}

type PopoverContentProps struct {
	ID               string
	Class            string
	Attributes       templ.Attributes
	Position         PopoverPosition
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
}

templ popoverPortalContainer() {
	<div
		id="popover-portal-container"
		class="fixed inset-0 z-[9999] pointer-events-none"
	></div>
}

templ PopoverTrigger(props ...PopoverTriggerProps) {
	{{ var p PopoverTriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = PopoverTriggerTypeClick }}
	}
	<span
		data-popover-trigger
		data-popover-id={ p.ID }
		data-popover-type={ string(p.TriggerType) }
	>
		{ children... }
	</span>
}

templ Popover(props ...PopoverProps) {
	{{ var p PopoverProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ utils.TwMerge("relative inline-block", p.Class) }>
		{ children... }
	</div>
	@popoverPortalContainer()
}

templ PopoverContent(props ...PopoverContentProps) {
	{{ var p PopoverContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Position == "" {
		{{ p.Position = PopoverBottom }}
	}
	<template
		data-popover-content-template
		data-popover-id={ p.ID }
		data-popover-position={ string(p.Position) }
		data-popover-disable-clickaway={ strconv.FormatBool(p.DisableClickAway) }
		data-popover-disable-esc={ strconv.FormatBool(p.DisableESC) }
		data-popover-show-arrow={ strconv.FormatBool(p.ShowArrow) }
	>
		<div
			class={ utils.TwMerge(
			"bg-background rounded-lg border text-sm shadow-lg pointer-events-auto absolute z-[9999]",
			p.Class,
		) }
		>
			<div class="w-full overflow-hidden">
				{ children... }
			</div>
			if p.ShowArrow {
				<div
					class={
						utils.TwMerge(
							"absolute h-2.5 w-2.5 rotate-45 bg-background",
							popoverArrowClass(p.Position),
						),
					}
				></div>
			}
		</div>
	</template>
}

func popoverArrowClass(side PopoverPosition) string {
	switch side {
	case PopoverTop:
		return "bottom-[-5px] left-1/2 -translate-x-1/2 border-b border-r"
	case PopoverTopStart:
		return "bottom-[-5px] left-4 border-b border-r"
	case PopoverTopEnd:
		return "bottom-[-5px] right-4 border-b border-r"
	case PopoverRight:
		return "left-[-5px] top-1/2 -translate-y-1/2 border-b border-l"
	case PopoverRightStart:
		return "left-[-5px] top-2 border-b border-l"
	case PopoverRightEnd:
		return "left-[-5px] bottom-2 border-b border-l"
	case PopoverBottom:
		return "top-[-5px] left-1/2 -translate-x-1/2 border-t border-l"
	case PopoverBottomStart:
		return "top-[-5px] left-4 border-t border-l"
	case PopoverBottomEnd:
		return "top-[-5px] right-4 border-t border-l"
	case PopoverLeft:
		return "right-[-5px] top-1/2 -translate-y-1/2 border-t border-r"
	case PopoverLeftStart:
		return "right-[-5px] top-2 border-t border-r"
	case PopoverLeftEnd:
		return "right-[-5px] bottom-2 border-t border-r"
	default:
		return "top-[-5px] left-1/2 -translate-x-1/2 border-t border-l"
	}
}

templ PopoverScript() {
	<script defer nonce={ templ.GetNonce(ctx) }>
        document.addEventListener('DOMContentLoaded', () => {
            const portalContainer = document.getElementById('popover-portal-container');
            const triggers = document.querySelectorAll('[data-popover-trigger]');
            const templates = document.querySelectorAll('[data-popover-content-template]');
            
            // Aktive Popovers
            const activePopovers = new Map();
            
            // Positionierungsfunktion
            const positionPopover = (trigger, popoverElement) => {
                // Finde das tatsächliche Element, auf das sich der Popover bezieht
                let triggerElement = trigger;
                let largestArea = 0;
                
                // Prüfe alle direkten Kinder des Triggers
                const children = trigger.children;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    const rect = child.getBoundingClientRect();
                    const area = rect.width * rect.height;
                    
                    if (area > largestArea) {
                        largestArea = area;
                        triggerElement = child;
                    }
                }
                
                const triggerRect = triggerElement.getBoundingClientRect();
                const contentRect = popoverElement.getBoundingClientRect();
                const margin = popoverElement.dataset.popoverShowArrow === 'true' ? 8 : 4;
                const scrollY = window.scrollY || window.pageYOffset;
                const scrollX = window.scrollX || window.pageXOffset;

                const position = popoverElement.dataset.popoverPosition || 'bottom';

                // Get element heights
                const triggerHeight = triggerRect.height;
                const contentHeight = contentRect.height;
                
                // Definiere Ankerpunkte
                const triggerTop = triggerRect.top + scrollY;
                const triggerBottom = triggerRect.bottom + scrollY;
                const triggerLeft = triggerRect.left + scrollX;
                const triggerRight = triggerRect.right + scrollX;
                
                let top, left;
                
                // Hier den restlichen Code für verschiedene Positionen einfügen...
                switch (position) {
                    case 'top':
                        top = triggerTop - contentHeight - margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                        break;
                    case 'top-start':
                        top = triggerTop - contentHeight - margin;
                        left = triggerLeft;
                        break;
                    case 'top-end':
                        top = triggerTop - contentHeight - margin;
                        left = triggerRight - contentRect.width;
                        break;
                    case 'right':
                        top = triggerTop + (triggerHeight / 2) - (contentHeight / 2);
                        left = triggerRight + margin;
                        break;
                    case 'right-start':
                        top = triggerTop;  // Exakt am oberen Rand ausrichten
                        left = triggerRight + margin;
                        break;
                    case 'right-end':
                        top = triggerBottom - contentHeight;  // Exakt am unteren Rand ausrichten
                        left = triggerRight + margin;
                        break;
                    case 'bottom':
                        top = triggerBottom + margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                        break;
                    case 'bottom-start':
                        top = triggerBottom + margin;
                        left = triggerLeft;
                        break;
                    case 'bottom-end':
                        top = triggerBottom + margin;
                        left = triggerRight - contentRect.width;
                        break;
                    case 'left':
                        top = triggerTop + (triggerHeight / 2) - (contentHeight / 2);
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    case 'left-start':
                        top = triggerTop;  // Exakt am oberen Rand ausrichten
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    case 'left-end':
                        top = triggerBottom - contentHeight;  // Exakt am unteren Rand ausrichten
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    default:
                        top = triggerBottom + margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                }

                popoverElement.style.top = `${top}px`;
                popoverElement.style.left = `${left}px`;
            };
            
            // Event-Handler einrichten
            function setupTrigger(trigger) {
                const popoverId = trigger.dataset.popoverId;
                const template = document.querySelector(`[data-popover-content-template][data-popover-id="${popoverId}"]`);
                
                if (!template) return;
                
                const triggerType = trigger.dataset.popoverType;
                
                // Click-Handler
                if (triggerType === 'click') {
                    trigger.addEventListener('click', () => {
                        // Wenn Popover bereits aktiv ist, entfernen
                        if (activePopovers.has(popoverId)) {
                            const popover = activePopovers.get(popoverId);
                            popover.remove();
                            activePopovers.delete(popoverId);
                            return;
                        }
                        
                        // Sonst neues Popover erstellen
                        const content = template.content.cloneNode(true).firstElementChild;
                        
                        // Attribute vom Template übertragen
                        Object.keys(template.dataset).forEach(key => {
                            if (key.startsWith('popover')) {
                                content.dataset[key] = template.dataset[key];
                            }
                        });
                        
                        // Zum Portal-Container hinzufügen
                        portalContainer.appendChild(content);
                        
                        // Positionieren
                        positionPopover(trigger, content);
                        
                        // In aktive Popovers einfügen
                        activePopovers.set(popoverId, content);
                        
                        // Clickaway-Handler hinzufügen
                        if (content.dataset.popoverDisableClickaway !== 'true') {
                            const clickHandler = (e) => {
                                if (!trigger.contains(e.target) && !content.contains(e.target)) {
                                    content.remove();
                                    activePopovers.delete(popoverId);
                                    document.removeEventListener('click', clickHandler);
                                }
                            };
                            
                            // Verzögerung, damit der aktuelle Klick nicht sofort wieder schließt
                            setTimeout(() => {
                                document.addEventListener('click', clickHandler);
                            }, 0);
                        }
                        
                        // ESC-Handler hinzufügen
                        if (content.dataset.popoverDisableEsc !== 'true') {
                            const keyHandler = (e) => {
                                if (e.key === 'Escape') {
                                    content.remove();
                                    activePopovers.delete(popoverId);
                                    document.removeEventListener('keydown', keyHandler);
                                }
                            };
                            document.addEventListener('keydown', keyHandler);
                        }
                    });
                } else if (triggerType === 'hover') {
                    // Hover-Handlers
                    let hoverTimeout;
                    let leaveTimeout;
                    
                    trigger.addEventListener('mouseenter', () => {
                        clearTimeout(leaveTimeout);
                        
                        // Wenn Popover bereits aktiv, nicht neu erstellen
                        if (activePopovers.has(popoverId)) return;
                        
                        // Neues Popover erstellen
                        const content = template.content.cloneNode(true).firstElementChild;
                        
                        // Attribute übertragen
                        Object.keys(template.dataset).forEach(key => {
                            if (key.startsWith('popover')) {
                                content.dataset[key] = template.dataset[key];
                            }
                        });
                        
                        // Zum Portal-Container hinzufügen
                        portalContainer.appendChild(content);
                        
                        // Positionieren
                        positionPopover(trigger, content);
                        
                        // In aktive Popovers einfügen
                        activePopovers.set(popoverId, content);
                        
                        // Hover-Handler für das Content-Element
                        content.addEventListener('mouseenter', () => {
                            clearTimeout(leaveTimeout);
                        });
                        
                        content.addEventListener('mouseleave', () => {
                            leaveTimeout = setTimeout(() => {
                                if (activePopovers.has(popoverId)) {
                                    const popover = activePopovers.get(popoverId);
                                    popover.remove();
                                    activePopovers.delete(popoverId);
                                }
                            }, 100);
                        });
                    });
                    
                    trigger.addEventListener('mouseleave', (e) => {
                        // Prüfen, ob wir zum Content hovern
                        const related = e.relatedTarget;
                        const content = activePopovers.get(popoverId);
                        
                        // Wenn wir direkt zum Content hovern, nicht schließen
                        if (content && content.contains(related)) {
                            return;
                        }
                        
                        leaveTimeout = setTimeout(() => {
                            if (activePopovers.has(popoverId)) {
                                const popover = activePopovers.get(popoverId);
                                popover.remove();
                                activePopovers.delete(popoverId);
                            }
                        }, 100);
                    });
                }
            }
            
            // Für jeden Trigger die Handler einrichten
            triggers.forEach(setupTrigger);
            
            // Scrolling-Handler für alle Popovers
            window.addEventListener('scroll', () => {
                activePopovers.forEach((content, popoverId) => {
                    const trigger = document.querySelector(`[data-popover-trigger][data-popover-id="${popoverId}"]`);
                    if (trigger) {
                        positionPopover(trigger, content);
                    }
                });
            }, { passive: true });
            
            // Resize-Handler
            window.addEventListener('resize', () => {
                activePopovers.forEach((content, popoverId) => {
                    const trigger = document.querySelector(`[data-popover-trigger][data-popover-id="${popoverId}"]`);
                    if (trigger) {
                        positionPopover(trigger, content);
                    }
                });
            });
            
            // Finde alle scrollbaren Elternelemente und füge Scroll-Handler hinzu
            function setupScrollHandlers() {
                const scrollableElements = new Set();
                
                // Für jeden Trigger die scrollbaren Eltern finden
                triggers.forEach(trigger => {
                    let element = trigger.parentElement;
                    
                    while (element) {
                        const style = window.getComputedStyle(element);
                        const overflow = style.overflow + style.overflowY + style.overflowX;
                        
                        if (overflow.includes('scroll') || overflow.includes('auto') || 
                            element.scrollHeight > element.clientHeight) {
                            scrollableElements.add(element);
                        }
                        
                        element = element.parentElement;
                    }
                });
                
                // Scroll-Handler für jedes scrollbare Element
                scrollableElements.forEach(element => {
                    element.addEventListener('scroll', () => {
                        activePopovers.forEach((content, popoverId) => {
                            const trigger = document.querySelector(`[data-popover-trigger][data-popover-id="${popoverId}"]`);
                            if (trigger) {
                                positionPopover(trigger, content);
                            }
                        });
                    }, { passive: true });
                });
            }
            
            setupScrollHandlers();
        });
    </script>
}
