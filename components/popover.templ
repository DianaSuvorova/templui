package components

import (
	"github.com/axzilla/templui/utils"
	"strconv"
)

type PopoverPosition string

const (
	PopoverTop         PopoverPosition = "top"
	PopoverTopStart    PopoverPosition = "top-start"
	PopoverTopEnd      PopoverPosition = "top-end"
	PopoverRight       PopoverPosition = "right"
	PopoverRightStart  PopoverPosition = "right-start"
	PopoverRightEnd    PopoverPosition = "right-end"
	PopoverBottom      PopoverPosition = "bottom"
	PopoverBottomStart PopoverPosition = "bottom-start"
	PopoverBottomEnd   PopoverPosition = "bottom-end"
	PopoverLeft        PopoverPosition = "left"
	PopoverLeftStart   PopoverPosition = "left-start"
	PopoverLeftEnd     PopoverPosition = "left-end"
)

type PopoverTriggerType string

const (
	PopoverTriggerTypeHover PopoverTriggerType = "hover"
	PopoverTriggerTypeClick PopoverTriggerType = "click"
)

type PopoverProps struct {
	Class string
}

type PopoverTriggerProps struct {
	ID          string
	TriggerType PopoverTriggerType
}

type PopoverContentProps struct {
	ID               string
	Class            string
	Attributes       templ.Attributes
	Position         PopoverPosition
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
}

templ popoverPortalContainer() {
	<div
		id="popover-portal-container"
		class="fixed inset-0 z-[9999] pointer-events-none"
	></div>
}

templ PopoverTrigger(props ...PopoverTriggerProps) {
	{{ var p PopoverTriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = PopoverTriggerTypeClick }}
	}
	<span
		data-popover-trigger
		data-popover-id={ p.ID }
		data-popover-type={ string(p.TriggerType) }
	>
		{ children... }
	</span>
}

templ Popover(props ...PopoverProps) {
	{{ var p PopoverProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ utils.TwMerge("relative inline-block", p.Class) }>
		{ children... }
	</div>
	@popoverPortalContainer()
}

templ PopoverContent(props ...PopoverContentProps) {
	{{ var p PopoverContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Position == "" {
		{{ p.Position = PopoverBottom }}
	}
	<template
		data-popover-content-template
		data-popover-id={ p.ID }
		data-popover-position={ string(p.Position) }
		data-popover-disable-clickaway={ strconv.FormatBool(p.DisableClickAway) }
		data-popover-disable-esc={ strconv.FormatBool(p.DisableESC) }
		data-popover-show-arrow={ strconv.FormatBool(p.ShowArrow) }
	>
		<div
			class={ utils.TwMerge(
			"bg-background rounded-lg border text-sm shadow-lg pointer-events-auto absolute z-[9999]",
			p.Class,
		) }
		>
			<div class="w-full overflow-hidden">
				{ children... }
			</div>
			if p.ShowArrow {
				<!-- Alle möglichen Pfeil-Varianten einfügen, damit sie bei Positionswechseln korrekt angezeigt werden -->
				<!-- Top-Pfeile -->
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background top-[-5px] left-1/2 -translate-x-1/2 border-t border-l"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background top-[-5px] left-4 border-t border-l"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background top-[-5px] right-4 border-t border-l"></div>
				<!-- Bottom-Pfeile -->
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background bottom-[-5px] left-1/2 -translate-x-1/2 border-b border-r"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background bottom-[-5px] left-4 border-b border-r"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background bottom-[-5px] right-4 border-b border-r"></div>
				<!-- Left-Pfeile -->
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background left-[-5px] top-1/2 -translate-y-1/2 border-b border-l"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background left-[-5px] top-2 border-b border-l"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background left-[-5px] bottom-2 border-b border-l"></div>
				<!-- Right-Pfeile -->
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background right-[-5px] top-1/2 -translate-y-1/2 border-t border-r"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background right-[-5px] top-2 border-t border-r"></div>
				<div class="absolute h-2.5 w-2.5 rotate-45 bg-background right-[-5px] bottom-2 border-t border-r"></div>
			}
		</div>
	</template>
}

templ PopoverScript() {
	<script defer nonce={ templ.GetNonce(ctx) }>
        document.addEventListener('DOMContentLoaded', () => {
            // Animation-Styles und dynamische Pfeil-Anpassung
            const style = document.createElement('style');
            style.textContent = `
                /* Alle Pfeile standardmäßig ausblenden */
                [data-popover-position] [class*="-[-5px]"] {
                    display: none;
                }
                
                /* Korrekte Pfeile basierend auf aktueller Position anzeigen */
                /* Top-Position - Pfeil unten */
                [data-popover-current-position="top"] [class*="bottom-[-5px]"].left-1\\/2 {
                    display: block;
                }
                
                [data-popover-current-position="top-start"] [class*="bottom-[-5px]"].left-4 {
                    display: block;
                }
                
                [data-popover-current-position="top-end"] [class*="bottom-[-5px]"].right-4 {
                    display: block;
                }
                
                /* Bottom-Position - Pfeil oben */
                [data-popover-current-position="bottom"] [class*="top-[-5px]"].left-1\\/2 {
                    display: block;
                }
                
                [data-popover-current-position="bottom-start"] [class*="top-[-5px]"].left-4 {
                    display: block;
                }
                
                [data-popover-current-position="bottom-end"] [class*="top-[-5px]"].right-4 {
                    display: block;
                }
                
                /* Left-Position - Pfeil rechts */
                [data-popover-current-position="left"] [class*="right-[-5px]"].top-1\\/2 {
                    display: block;
                }
                
                [data-popover-current-position="left-start"] [class*="right-[-5px]"].top-2 {
                    display: block;
                }
                
                [data-popover-current-position="left-end"] [class*="right-[-5px]"].bottom-2 {
                    display: block;
                }
                
                /* Right-Position - Pfeil links */
                [data-popover-current-position="right"] [class*="left-[-5px]"].top-1\\/2 {
                    display: block;
                }
                
                [data-popover-current-position="right-start"] [class*="left-[-5px]"].top-2 {
                    display: block;
                }
                
                [data-popover-current-position="right-end"] [class*="left-[-5px]"].bottom-2 {
                    display: block;
                }
            `;
            document.head.appendChild(style);
            
            const portalContainer = document.getElementById('popover-portal-container');
            const triggers = document.querySelectorAll('[data-popover-trigger]');
            const templates = document.querySelectorAll('[data-popover-content-template]');
            
            // Aktive Popovers
            const activePopovers = new Map();
            
            // Positionierungsfunktion
            const positionPopover = (trigger, popoverElement) => {
                // Finde das tatsächliche Element, auf das sich der Popover bezieht
                let triggerElement = trigger;
                let largestArea = 0;
                
                // Prüfe alle direkten Kinder des Triggers
                const children = trigger.children;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    const rect = child.getBoundingClientRect();
                    const area = rect.width * rect.height;
                    
                    if (area > largestArea) {
                        largestArea = area;
                        triggerElement = child;
                    }
                }
                
                const triggerRect = triggerElement.getBoundingClientRect();
                const contentRect = popoverElement.getBoundingClientRect();
                const margin = popoverElement.dataset.popoverShowArrow === 'true' ? 8 : 4;
                const scrollY = window.scrollY || window.pageYOffset;
                const scrollX = window.scrollX || window.pageXOffset;

                // Position aus dem Datensatz abrufen
                const requestedPosition = popoverElement.dataset.popoverPosition || 'bottom';
                // Wir speichern die finale Position, die je nach Viewport-Raum angepasst werden kann
                let finalPosition = requestedPosition;

                // Viewport-Dimensionen
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Get element heights and widths
                const triggerHeight = triggerRect.height;
                const contentHeight = contentRect.height;
                const contentWidth = contentRect.width;
                
                // Definiere Ankerpunkte
                const triggerTop = triggerRect.top + scrollY;
                const triggerBottom = triggerRect.bottom + scrollY;
                const triggerLeft = triggerRect.left + scrollX;
                const triggerRight = triggerRect.right + scrollX;
                
                // Berechne verfügbaren Platz in jede Richtung
                const spaceAbove = triggerRect.top;
                const spaceBelow = viewportHeight - triggerRect.bottom;
                const spaceLeft = triggerRect.left;
                const spaceRight = viewportWidth - triggerRect.right;

                // Intelligente Positionsanpassung
                // Wir prüfen die gegensätzliche Position, wenn nicht genug Platz vorhanden ist
                if (finalPosition.startsWith('top') && spaceAbove < contentHeight + margin) {
                    // Wenn oben nicht genug Platz ist, unten anzeigen
                    finalPosition = finalPosition.replace('top', 'bottom');
                } else if (finalPosition.startsWith('bottom') && spaceBelow < contentHeight + margin) {
                    // Wenn unten nicht genug Platz ist, oben anzeigen
                    finalPosition = finalPosition.replace('bottom', 'top');
                } else if (finalPosition.startsWith('left') && spaceLeft < contentWidth + margin) {
                    // Wenn links nicht genug Platz ist, rechts anzeigen
                    finalPosition = finalPosition.replace('left', 'right');
                } else if (finalPosition.startsWith('right') && spaceRight < contentWidth + margin) {
                    // Wenn rechts nicht genug Platz ist, links anzeigen
                    finalPosition = finalPosition.replace('right', 'left');
                }

                // Speichere die aktuelle Position im Element für CSS-Anpassungen (z.B. Pfeil-Position)
                popoverElement.dataset.popoverCurrentPosition = finalPosition;
                
                let top, left;
                
                // Positionierungslogik mit der finalen Position
                switch (finalPosition) {
                    case 'top':
                        top = triggerTop - contentHeight - margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                        break;
                    case 'top-start':
                        top = triggerTop - contentHeight - margin;
                        left = triggerLeft;
                        break;
                    case 'top-end':
                        top = triggerTop - contentHeight - margin;
                        left = triggerRight - contentRect.width;
                        break;
                    case 'right':
                        top = triggerTop + (triggerHeight / 2) - (contentHeight / 2);
                        left = triggerRight + margin;
                        break;
                    case 'right-start':
                        top = triggerTop;
                        left = triggerRight + margin;
                        break;
                    case 'right-end':
                        top = triggerBottom - contentHeight;
                        left = triggerRight + margin;
                        break;
                    case 'bottom':
                        top = triggerBottom + margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                        break;
                    case 'bottom-start':
                        top = triggerBottom + margin;
                        left = triggerLeft;
                        break;
                    case 'bottom-end':
                        top = triggerBottom + margin;
                        left = triggerRight - contentRect.width;
                        break;
                    case 'left':
                        top = triggerTop + (triggerHeight / 2) - (contentHeight / 2);
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    case 'left-start':
                        top = triggerTop;
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    case 'left-end':
                        top = triggerBottom - contentHeight;
                        left = triggerLeft - contentRect.width - margin;
                        break;
                    default:
                        top = triggerBottom + margin;
                        left = triggerLeft + (triggerRect.width / 2) - (contentRect.width / 2);
                }

                // Horizontale Begrenzung - sorgt dafür, dass der Popover nicht aus dem Viewport ragt
                if (left < 10) {
                    left = 10; // Minimaler Abstand vom linken Rand
                } else if (left + contentWidth > viewportWidth - 10) {
                    left = viewportWidth - contentWidth - 10; // Minimaler Abstand vom rechten Rand
                }

                // Vertikale Begrenzung - Optional, kann in manchen Fällen problematisch sein
                if (top < 10) {
                    top = 10; // Minimaler Abstand vom oberen Rand
                } else if (top + contentHeight > viewportHeight - 10) {
                    top = viewportHeight - contentHeight - 10; // Minimaler Abstand vom unteren Rand
                }

                popoverElement.style.top = `${top}px`;
                popoverElement.style.left = `${left}px`;
            };
            
            // Event-Handler einrichten
            function setupTrigger(trigger) {
                const popoverId = trigger.dataset.popoverId;
                const template = document.querySelector(`[data-popover-content-template][data-popover-id="${popoverId}"]`);
                
                if (!template) return;
                
                const triggerType = trigger.dataset.popoverType;
                
                // Click-Handler
                if (triggerType === 'click') {
                    trigger.addEventListener('click', () => {
                        // Wenn Popover bereits aktiv ist, entfernen
                        if (activePopovers.has(popoverId)) {
                            const popover = activePopovers.get(popoverId);
                            popover.remove();
                            activePopovers.delete(popoverId);
                            return;
                        }
                        
                        // Sonst neues Popover erstellen
                        const content = template.content.cloneNode(true).firstElementChild;
                        
                        // Attribute vom Template übertragen
                        Object.keys(template.dataset).forEach(key => {
                            if (key.startsWith('popover')) {
                                content.dataset[key] = template.dataset[key];
                            }
                        });
                        
                        // Initiale Position setzen (kann später durch Smart Positioning geändert werden)
                        content.dataset.popoverCurrentPosition = content.dataset.popoverPosition;
                        
                        // Zum Portal-Container hinzufügen
                        portalContainer.appendChild(content);
                        
                        // Positionieren
                        positionPopover(trigger, content);
                        
                        // In aktive Popovers einfügen
                        activePopovers.set(popoverId, content);
                        
                        // Clickaway-Handler hinzufügen
                        if (content.dataset.popoverDisableClickaway !== 'true') {
                            const clickHandler = (e) => {
                                if (!trigger.contains(e.target) && !content.contains(e.target)) {
                                    content.remove();
                                    activePopovers.delete(popoverId);
                                    document.removeEventListener('click', clickHandler);
                                }
                            };
                            
                            // Verzögerung, damit der aktuelle Klick nicht sofort wieder schließt
                            setTimeout(() => {
                                document.addEventListener('click', clickHandler);
                            }, 0);
                        }
                        
                        // ESC-Handler hinzufügen
                        if (content.dataset.popoverDisableEsc !== 'true') {
                            const keyHandler = (e) => {
                                if (e.key === 'Escape') {
                                    content.remove();
                                    activePopovers.delete(popoverId);
                                    document.removeEventListener('keydown', keyHandler);
                                }
                            };
                            document.addEventListener('keydown', keyHandler);
                        }
                    });
                } else if (triggerType === 'hover') {
                    // Hover-Handlers
                    let hoverTimeout;
                    let leaveTimeout;
                    
                    trigger.addEventListener('mouseenter', () => {
                        clearTimeout(leaveTimeout);
                        
                        // Wenn Popover bereits aktiv, nicht neu erstellen
                        if (activePopovers.has(popoverId)) return;
                        
                        // Neues Popover erstellen
                        const content = template.content.cloneNode(true).firstElementChild;
                        
                        // Attribute übertragen
                        Object.keys(template.dataset).forEach(key => {
                            if (key.startsWith('popover')) {
                                content.dataset[key] = template.dataset[key];
                            }
                        });
                        
                        // Zum Portal-Container hinzufügen
                        portalContainer.appendChild(content);
                        
                        // Positionieren
                        positionPopover(trigger, content);
                        
                        // In aktive Popovers einfügen
                        activePopovers.set(popoverId, content);
                        
                        // Hover-Handler für das Content-Element
                        content.addEventListener('mouseenter', () => {
                            clearTimeout(leaveTimeout);
                        });
                        
                        content.addEventListener('mouseleave', () => {
                            leaveTimeout = setTimeout(() => {
                                if (activePopovers.has(popoverId)) {
                                    const popover = activePopovers.get(popoverId);
                                    popover.remove();
                                    activePopovers.delete(popoverId);
                                }
                            }, 100);
                        });
                    });
                    
                    trigger.addEventListener('mouseleave', (e) => {
                        // Prüfen, ob wir zum Content hovern
                        const related = e.relatedTarget;
                        const content = activePopovers.get(popoverId);
                        
                        // Wenn wir direkt zum Content hovern, nicht schließen
                        if (content && content.contains(related)) {
                            return;
                        }
                        
                        leaveTimeout = setTimeout(() => {
                            if (activePopovers.has(popoverId)) {
                                const popover = activePopovers.get(popoverId);
                                popover.remove();
                                activePopovers.delete(popoverId);
                            }
                        }, 100);
                    });
                }
            }
            
            // Für jeden Trigger die Handler einrichten
            triggers.forEach(setupTrigger);
            
            // Scrolling-Handler für alle Popovers
            window.addEventListener('scroll', () => {
                activePopovers.forEach((content, popoverId) => {
                    const trigger = document.querySelector(`[data-popover-trigger][data-popover-id="${popoverId}"]`);
                    if (trigger) {
                        positionPopover(trigger, content);
                    }
                });
            }, { passive: true });
            
            // Resize-Handler
            window.addEventListener('resize', () => {
                activePopovers.forEach((content, popoverId) => {
                    const trigger = document.querySelector(`[data-popover-trigger][data-popover-id="${popoverId}"]`);
                    if (trigger) {
                        positionPopover(trigger, content);
                    }
                });
            });
            
            // Finde alle scrollbaren Elternelemente und füge Scroll-Handler hinzu
            function setupScrollHandlers() {
                const scrollableElements = new Set();
                
                // Für jeden Trigger die scrollbaren Eltern finden
                triggers.forEach(trigger => {
                    let element = trigger.parentElement;
                    
                    while (element) {
                        const style = window.getComputedStyle(element);
                        const overflow = style.overflow + style.overflowY + style.overflowX;
                        
                        if (overflow.includes('scroll') || overflow.includes('auto') || 
                            element.scrollHeight > element.clientHeight) {
                            scrollableElements.add(element);
                        }
                        
                        element = element.parentElement;
                    }
                });
                
                // Scroll-Handler für jedes scrollbare Element
                scrollableElements.forEach(element => {
                    element.addEventListener('scroll', () => {
                        activePopovers.forEach((content, popoverId) => {
                            const trigger = document.querySelector(`[data-popover-trigger][data-popover-id="${popoverId}"]`);
                            if (trigger) {
                                positionPopover(trigger, content);
                            }
                        });
                    }, { passive: true });
                });
            }
            
            setupScrollHandlers();
        });
    </script>
}
