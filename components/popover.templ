package components

import "github.com/axzilla/templui/utils"

type PopoverPlacement string

const (
	PopoverTop         PopoverPlacement = "top"
	PopoverTopStart    PopoverPlacement = "top-start"
	PopoverTopEnd      PopoverPlacement = "top-end"
	PopoverRight       PopoverPlacement = "right"
	PopoverRightStart  PopoverPlacement = "right-start"
	PopoverRightEnd    PopoverPlacement = "right-end"
	PopoverBottom      PopoverPlacement = "bottom"
	PopoverBottomStart PopoverPlacement = "bottom-start"
	PopoverBottomEnd   PopoverPlacement = "bottom-end"
	PopoverLeft        PopoverPlacement = "left"
	PopoverLeftStart   PopoverPlacement = "left-start"
	PopoverLeftEnd     PopoverPlacement = "left-end"
)

type PopoverTriggerType string

const (
	PopoverTriggerTypeHover PopoverTriggerType = "hover"
	PopoverTriggerTypeClick PopoverTriggerType = "click"
)

type PopoverProps struct {
	Class string
}

type PopoverTriggerProps struct {
	ID          string
	TriggerType PopoverTriggerType
}

type PopoverContentProps struct {
	ID               string
	Class            string
	Attributes       templ.Attributes
	Placement        PopoverPlacement
	ContainerClass   string
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
}

templ PopoverTrigger(props ...PopoverTriggerProps) {
	{{ var p PopoverTriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = PopoverTriggerTypeClick }}
	}
	<span
		x-data="popoverTrigger"
		data-popover-id={ p.ID }
		data-popover-trigger={ string(p.TriggerType) }
		@mouseenter="openPopover"
		@mouseleave="closePopover"
		@focus="openPopover"
		@blur="closePopover"
		@click="togglePopover"
	>
		{ children... }
	</span>
}

templ Popover(props ...PopoverProps) {
	{{ var p PopoverProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ utils.TwMerge("relative", p.Class) }>
		{ children... }
	</div>
}

templ PopoverContent(props ...PopoverContentProps) {
	{{ var p PopoverContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Placement == "" {
		{{ p.Placement = PopoverBottom }}
	}
	<div
		x-data="popover"
		x-on:open-popover.window="handleOpenPopover"
		x-on:close-popover.window="handleClosePopover"
		x-on:toggle-popover.window="handleTogglePopover"
		data-popover-id={ p.ID }
		x-show="open"
		x-cloak
		x-transition:enter="transition ease-out duration-100"
		x-transition:enter-start="opacity-0 scale-95"
		x-transition:enter-end="opacity-100 scale-100"
		x-transition:leave="transition ease-in duration-75"
		x-transition:leave-start="opacity-100 scale-100"
		x-transition:leave-end="opacity-0 scale-95"
		class={
			utils.TwMerge(
				"absolute z-50 flex origin-center flex-col items-center justify-center will-change-transform",
				popoverContentClass(p.Placement, p.ShowArrow),
				p.ContainerClass,
			),
		}
	>
		<div
			if !p.DisableClickAway {
				x-on:click.outside="handleClosePopover"
			}
			if !p.DisableESC {
				x-on:keydown.esc.window="handleClosePopover"
			}
			class={
				utils.TwMerge(
					"bg-background w-full overflow-hidden rounded-lg border transition-opacity text-start text-sm",
					"overflow-scroll",
					p.Class,
				),
			}
		>
			{ children... }
		</div>
		if p.ShowArrow {
			<div
				class={
					utils.TwMerge(
						"absolute h-2 w-2 rotate-45 bg-background",
						popoverArrowClass(p.Placement),
					),
				}
			></div>
		}
	</div>
}

func popoverContentClass(side PopoverPlacement, showArrow bool) string {
	margin := "1"
	if showArrow {
		margin = "2"
	}

	switch side {
	// Top placements
	case PopoverTop:
		return "bottom-full start-1/2 -translate-x-1/2 mb-" + margin
	case PopoverTopStart:
		return "bottom-full start-0 mb-" + margin
	case PopoverTopEnd:
		return "bottom-full end-0 mb-" + margin

	// Right placements
	case PopoverRight:
		return "start-full top-1/2 -translate-y-1/2 ml-" + margin
	case PopoverRightStart:
		return "start-full top-0 ml-" + margin
	case PopoverRightEnd:
		return "start-full bottom-0 ml-" + margin

	// Bottom placements
	case PopoverBottom:
		return "top-full start-1/2 -translate-x-1/2 mt-" + margin
	case PopoverBottomStart:
		return "top-full start-0 mt-" + margin
	case PopoverBottomEnd:
		return "top-full end-0 mt-" + margin

	// Left placements
	case PopoverLeft:
		return "end-full top-1/2 -translate-y-1/2 mr-" + margin
	case PopoverLeftStart:
		return "end-full top-0 mr-" + margin
	case PopoverLeftEnd:
		return "end-full bottom-0 mr-" + margin

	default:
		return "bottom-full start-1/2 -translate-x-1/2 mb-" + margin
	}
}

func popoverArrowClass(side PopoverPlacement) string {
	switch side {
	// Top placements
	case PopoverTop:
		return "bottom-[-4px] left-1/2 -translate-x-1/2 border-b border-r"
	case PopoverTopStart:
		return "bottom-[-4px] left-4 border-b border-r"
	case PopoverTopEnd:
		return "bottom-[-4px] right-4 border-b border-r"

	// Right placements
	case PopoverRight:
		return "left-[-4px] top-1/2 -translate-y-1/2 border-b border-l"
	case PopoverRightStart:
		return "left-[-4px] top-4 border-b border-l"
	case PopoverRightEnd:
		return "left-[-4px] bottom-4 border-b border-l"

	// Bottom placements
	case PopoverBottom:
		return "top-[-4px] left-1/2 -translate-x-1/2 border-t border-l"
	case PopoverBottomStart:
		return "top-[-4px] left-4 border-t border-l"
	case PopoverBottomEnd:
		return "top-[-4px] right-4 border-t border-l"

	// Left placements
	case PopoverLeft:
		return "right-[-4px] top-1/2 -translate-y-1/2 border-t border-r"
	case PopoverLeftStart:
		return "right-[-4px] top-4 border-t border-r"
	case PopoverLeftEnd:
		return "right-[-4px] bottom-4 border-t border-r"

	default:
		return "bottom-[-4px] left-1/2 -translate-x-1/2 border-b border-r"
	}
}

templ PopoverScript() {
	{{ handler := templ.NewOnceHandle() }}
	@handler.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
            document.addEventListener('alpine:init', () => {
                Alpine.data('popover', () => ({
                    open: false,

                    handleOpenPopover(event) {
                        if (event.detail.id === this.$el.dataset.popoverId) {
                            this.open = true;
                        }
                    },

                    handleClosePopover(event) {
                        if (event.detail.id === this.$el.dataset.popoverId) {
                            this.open = false;
                        }
                    },

                    handleTogglePopover(event) {
                        if (event.detail.id === this.$el.dataset.popoverId) {
                            this.open = !this.open;
                        }
                    },
                }));

                Alpine.data('popoverTrigger', () => ({
                    openPopover() {
                        if (this.$el.dataset.popoverTrigger === "hover"){
                            this.$dispatch('open-popover', {
                                id: this.$el.dataset.popoverId
                            })
                        }
                    },
                    closePopover() {
                        if (this.$el.dataset.popoverTrigger === "hover"){
                            this.$dispatch('close-popover', {
                                id: this.$el.dataset.popoverId
                            })
                        }
                    },
                    togglePopover() {
                        this.$dispatch('toggle-popover', {
                            id: this.$el.dataset.popoverId
                        })
                    }
                }))
            })
        </script>
	}
}
