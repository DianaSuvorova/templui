package components

import (
	"github.com/axzilla/templui/icons"
	"github.com/axzilla/templui/utils"
	"strconv"
)

type RatingSize string
type RatingStyle string

const (
	RatingStyleStar    RatingStyle = "star"
	RatingStyleHeart   RatingStyle = "heart"
	RatingStyleEmoji   RatingStyle = "emoji"
	RatingStyleNumeric RatingStyle = "numeric"
)

type RatingProps struct {
	Value       float64
	MaxValue    int
	ReadOnly    bool
	Style       RatingStyle
	Size        RatingSize
	Precision   float64
	Name        string
	ShowValue   bool
	OnlyInteger bool
	Class       string
	Attributes  templ.Attributes
}

func (p *RatingProps) setDefaults() {
	if p.MaxValue <= 0 {
		p.MaxValue = 5
	}
	if p.Precision <= 0 {
		p.Precision = 1.0
	}
	if p.Style == "" {
		p.Style = RatingStyleStar
	}
}

func getColorClass(style RatingStyle) string {
	switch style {
	case RatingStyleHeart:
		return "text-destructive"
	case RatingStyleEmoji:
		return "text-yellow-500"
	default:
		return "text-yellow-400"
	}
}

func getRatingIcon(style RatingStyle, filled bool, value float64) templ.Component {
	if style == RatingStyleEmoji {
		if filled {
			switch {
			case value <= 1:
				return icons.Angry(icons.IconProps{})
			case value <= 2:
				return icons.Frown(icons.IconProps{})
			case value <= 3:
				return icons.Meh(icons.IconProps{})
			case value <= 4:
				return icons.Smile(icons.IconProps{})
			default:
				return icons.Laugh(icons.IconProps{})
			}
		}
		return icons.Meh(icons.IconProps{})
	}
	if filled {
		switch style {
		case RatingStyleHeart:
			return icons.Heart(icons.IconProps{Fill: "currentColor"})
		default:
			return icons.Star(icons.IconProps{Fill: "currentColor"})
		}
	} else {
		switch style {
		case RatingStyleHeart:
			return icons.Heart(icons.IconProps{})
		default:
			return icons.Star(icons.IconProps{})
		}
	}
}

templ RatingScript() {
	{{ handle := templ.NewOnceHandle() }}
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			document.addEventListener('alpine:init', () => {
				Alpine.data('rating', () => ({
					value: 0,
					maxValue: 5,
					precision: 1,
					readonly: false,
					name: '',
					onlyInteger: false,
					previewValue: 0,
					
					init() {
						this.value = parseFloat(this.$el.dataset.value) || 0;
						this.maxValue = parseInt(this.$el.dataset.maxvalue) || 5;
						this.precision = parseFloat(this.$el.dataset.precision) || 1;
						this.readonly = this.$el.dataset.readonly === 'true';
						this.name = this.$el.dataset.name || '';
						this.onlyInteger = this.$el.dataset.onlyinteger === 'true';
						this.value = Math.round(this.value / this.precision) * this.precision;
					},
					
					setValue() {
						if (this.readonly) return;
						const item = this.$event.target.closest('[data-rating-value]');
						if (!item) return;
						const newValue = parseInt(item.dataset.ratingValue);
						if (this.onlyInteger) {
							this.value = Math.round(newValue);
						} else {
							this.value = Math.round(newValue / this.precision) * this.precision;
						}
						this.value = Math.max(0, Math.min(this.maxValue, this.value));
						this.$dispatch('rating-change', { 
							name: this.name, 
							value: this.value 
						});
					},
					
					getFormattedValue() {
						return Math.round(this.value * 100) / 100;
					},
					
					getItemStyle() {
						const index = parseInt(this.$el.dataset.index || '0');
						const filled = index <= Math.floor(this.value);
						const partial = !filled && (index - 1 < this.value && this.value < index);
						const percentage = partial ? (this.value - Math.floor(this.value)) * 100 : 0;
						return {
							width: filled ? '100%' : (partial ? percentage + '%' : '0%')
						};
					},
					
					hover() {
						if (this.readonly) return;
						const item = this.$event.target.closest('[data-rating-value]');
						if (!item) return;
						this.previewValue = parseInt(item.dataset.ratingValue);
					},
					
					getCursorClass() {
						return this.readonly ? 'cursor-default' : 'cursor-pointer';
					}
				}));
			});
		</script>
	}
}

templ Rating(props RatingProps) {
	{{ props.setDefaults() }}
	<div
		x-data="rating"
		data-value={ strconv.FormatFloat(props.Value, 'f', -1, 64) }
		data-maxvalue={ strconv.Itoa(props.MaxValue) }
		data-precision={ strconv.FormatFloat(props.Precision, 'f', -1, 64) }
		data-readonly={ strconv.FormatBool(props.ReadOnly) }
		data-name={ props.Name }
		data-onlyinteger={ strconv.FormatBool(props.OnlyInteger) }
		class={ utils.TwMerge(
			"flex flex-col items-start gap-1",
			props.Class,
		) }
		{ props.Attributes... }
	>
		<div class="flex items-center gap-1">
			if props.Style != RatingStyleNumeric {
				for i := 1; i <= props.MaxValue; i++ {
					<div
						class={
							utils.TwMerge(
								"relative",
								getColorClass(props.Style),
								"transition-opacity",
							),
							templ.KV("cursor-pointer", !props.ReadOnly),
							templ.KV("cursor-default", props.ReadOnly),
						}
						data-rating-value={ strconv.Itoa(i) }
						@click="setValue"
						@mouseover="hover"
					>
						<div class="opacity-30">
							@getRatingIcon(props.Style, false, float64(i))
						</div>
						<div
							class="absolute inset-0 overflow-hidden"
							x-bind:style="getItemStyle"
							data-index={ strconv.Itoa(i) }
						>
							@getRatingIcon(props.Style, true, float64(i))
						</div>
					</div>
				}
			} else {
				<span class={ utils.TwMerge("font-bold") }>
					<span x-text="getFormattedValue"></span>
					<span>/ </span><span x-text="maxValue"></span>
				</span>
				<span class={ utils.TwMerge(getColorClass(RatingStyleStar)) }>
					@icons.Star(icons.IconProps{})
				</span>
			}
			if props.Name != "" {
				<input
					type="hidden"
					name={ props.Name }
					x-bind:value="value"
				/>
			}
		</div>
	</div>
}
