package components

import (
	"github.com/axzilla/templui/icons"
	"github.com/axzilla/templui/utils"
	"time"
)

type DateFormat string

const (
	DateFormatISO  DateFormat = "iso"
	DateFormatEU   DateFormat = "eu"
	DateFormatUK   DateFormat = "uk"
	DateFormatUS   DateFormat = "us"
	DateFormatLONG DateFormat = "long"
)

var dateFormatMapping = map[DateFormat]string{
	DateFormatISO:  "2006-01-02",
	DateFormatEU:   "02.01.2006",
	DateFormatUK:   "02/01/2006",
	DateFormatUS:   "01/02/2006",
	DateFormatLONG: "January 2, 2006",
}

type DateLocale struct {
	MonthNames []string
	DayNames   []string
}

var (
	DateLocaleDefault = DateLocale{
		MonthNames: []string{"January", "February", "March", "April", "May", "June",
			"July", "August", "September", "October", "November", "December"},
		DayNames: []string{"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"},
	}

	DateLocaleSpanish = DateLocale{
		MonthNames: []string{"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
			"Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"},
		DayNames: []string{"Lu", "Ma", "Mi", "Ju", "Vi", "Sa", "Do"},
	}

	DateLocaleGerman = DateLocale{
		MonthNames: []string{"Januar", "Februar", "März", "April", "Mai", "Juni",
			"Juli", "August", "September", "Oktober", "November", "Dezember"},
		DayNames: []string{"Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"},
	}

	DateLocaleFrench = DateLocale{
		MonthNames: []string{"Janvier", "Février", "Mars", "Avril", "Mai", "Juin",
			"Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"},
		DayNames: []string{"Lu", "Ma", "Me", "Je", "Ve", "Sa", "Di"},
	}

	DateLocaleItalian = DateLocale{
		MonthNames: []string{"Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
			"Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"},
		DayNames: []string{"Lu", "Ma", "Me", "Gi", "Ve", "Sa", "Do"},
	}

	DateLocaleJapanese = DateLocale{
		MonthNames: []string{"1月", "2月", "3月", "4月", "5月", "6月",
			"7月", "8月", "9月", "10月", "11月", "12月"},
		DayNames: []string{"日", "月", "火", "水", "木", "金", "土"},
	}
)

var (
	DatePickerISO = DatePickerConfig{
		Format: DateFormatISO,
		Locale: DateLocaleDefault,
	}

	DatePickerEU = DatePickerConfig{
		Format: DateFormatEU,
		Locale: DateLocaleDefault,
	}

	DatePickerUK = DatePickerConfig{
		Format: DateFormatUK,
		Locale: DateLocaleDefault,
	}

	DatePickerUS = DatePickerConfig{
		Format: DateFormatUS,
		Locale: DateLocaleDefault,
	}

	DatePickerLONG = DatePickerConfig{
		Format: DateFormatLONG,
		Locale: DateLocaleDefault,
	}
)

func NewDatePickerConfig(format DateFormat, locale DateLocale) DatePickerConfig {
	return DatePickerConfig{
		Format: format,
		Locale: locale,
	}
}

type DatePickerConfig struct {
	Format DateFormat
	Locale DateLocale
}

// Alle anderen DateFormat, DateLocale, etc. Definitionen bleiben unverändert

type DatePickerProps struct {
	ID          string
	Class       string
	Attributes  templ.Attributes
	Value       time.Time
	Config      DatePickerConfig
	Placeholder string
	Disabled    bool
	HasError    bool
	Name        string
}

// Alle vorhandenen DateFormat, DateLocale, etc. bleiben unverändert
templ DatePicker(props ...DatePickerProps) {
	{{ var p DatePickerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.ID == "" {
		{{ p.ID = utils.RandomID() }}
	}
	if p.Placeholder == "" {
		{{ p.Placeholder = "Select a date" }}
	}
	<!-- Container für den gesamten DatePicker -->
	<div
		id={ p.ID }
		class={ utils.TwMerge("relative", p.Class) }
		if p.Value != (time.Time{}) {
			data-value={ p.Value.Format(p.Config.getGoFormat()) }
		}
		data-format={ string(p.Config.Format) }
		data-monthnames={ templ.JSONString(p.Config.Locale.MonthNames) }
		data-daynames={ templ.JSONString(p.Config.Locale.DayNames) }
		x-data="date-picker"
		data-input-id={ p.ID }
		@resize.window="updatePosition"
		{ p.Attributes... }
	>
		<!-- Verstecktes Input für Formularwert -->
		<input
			type="hidden"
			id={ p.ID + "-hidden" }
			name={ p.Name }
			x-ref="hiddenInput"
			disabled?={ p.Disabled }
		/>
		<div class="relative">
			<!-- Button statt Input -->
			<button
				type="button"
				id={ p.ID + "-trigger" }
				@click="toggleDatePicker"
				x-ref="triggerButton"
				disabled?={ p.Disabled }
				class={ utils.TwMerge(
						"w-full h-10 px-3 py-2 rounded-md border bg-background text-sm flex items-center justify-between",
						"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
						"disabled:cursor-not-allowed disabled:opacity-50",
						utils.IfElse(p.HasError, "border-destructive ring-destructive", "border-input"),
					) }
			>
				<!-- Display für das ausgewählte Datum -->
				<span
					x-ref="displayText"
					class="text-left grow"
				>
					if p.Value != (time.Time{}) {
						{ p.Value.Format(p.Config.getGoFormat()) }
					} else {
						<span class="text-muted-foreground">{ p.Placeholder }</span>
					}
				</span>
				<!-- Kalender-Icon -->
				<span class="text-muted-foreground flex items-center">
					@icons.Calendar()
				</span>
			</button>
		</div>
		<!-- Rest des DatePickers bleibt unverändert -->
		<div
			x-show="open"
			x-ref="datePickerPopup"
			@click.away="closeDatePicker"
			x-transition.opacity
			class={
				utils.TwMerge(
					"absolute left-0 z-50 w-64 p-4",
					"rounded-lg border bg-popover shadow-md",
				),
			}
			x-bind:class="positionClass"
		>
			<div class="flex items-center justify-between mb-4">
				<span x-ref="monthDisplay" class="text-sm font-medium"></span>
				<div class="flex gap-1">
					<button
						type="button"
						@click="atClickPrevMonth"
						class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground h-7 w-7"
					>
						@icons.ChevronLeft()
					</button>
					<button
						type="button"
						@click="atClickNextMonth"
						class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground h-7 w-7"
					>
						@icons.ChevronRight()
					</button>
				</div>
			</div>
			<div class="grid grid-cols-7 gap-1 mb-2">
				<template x-for="day in days">
					<div class="text-center text-xs text-muted-foreground" x-ref="dayLabels"></div>
				</template>
			</div>
			<div class="grid grid-cols-7 gap-1">
				<template x-for="blank in blankDays">
					<div class="h-8 w-8"></div>
				</template>
				<template x-for="day in monthDays">
					<button
						type="button"
						@click="selectDate"
						x-ref="dayButtons"
						class="inline-flex h-8 w-8 items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
					></button>
				</template>
			</div>
		</div>
	</div>
}

func (c DatePickerConfig) getGoFormat() string {
	if format, ok := dateFormatMapping[c.Format]; ok {
		return format
	}
	return dateFormatMapping[DateFormatISO]
}

// Angepasstes DatePicker-Script
templ DatePickerScript() {
	{{ handle := templ.NewOnceHandle() }}
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			document.addEventListener('alpine:init', () => {
				Alpine.data('date-picker', () => ({
					open: false,
					value: null,
					format: null,
					currentMonth: 5,
					currentYear: new Date().getFullYear(),
					monthDays: [],
					blankDays: [],
					months: [],
					days: [],
					position: 'bottom',

					init() {
						try {
						    // Monatsnamen parsen
						    this.months = JSON.parse(this.$el.dataset.monthnames || '[]');
						    if (!this.months || !this.months.length) {
						        this.months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
						    }
						    
						    // Tagesnamen parsen
						    this.days = JSON.parse(this.$el.dataset.daynames || '[]');
						    if (!this.days || !this.days.length) {
						        this.days = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'];
						    }
						    
                            // Format setzen
							this.format = this.$el.dataset.format;
							
							// Initialen Wert verarbeiten
							const initialValue = this.$el.dataset.value;
							if (initialValue) {
								const initialDate = new Date(this.parseDate(initialValue));
								this.currentMonth = initialDate.getMonth();
								this.currentYear = initialDate.getFullYear();
								this.value = this.formatDate(initialDate);
								
								// Hidden Input aktualisieren
								this.$refs.hiddenInput.value = this.value;
							}
							
							this.calculateDays();
							this.updateDayDisplay();
							this.updateMonthDisplay();
						} catch(e) {
						    console.error('DatePicker initialization error:', e);
						}
					},

					toggleDatePicker() {
						if (this.$refs.triggerButton.disabled) {
							return;
						}
						
						this.open = !this.open;
						if (this.open) {
							this.$nextTick(() => {
								this.updatePosition();
								this.updateDayDisplay();
							});
						}
					},
					
					updateMonthDisplay() {
					    if (this.$refs.monthDisplay) {
					        this.$refs.monthDisplay.textContent = this.months[this.currentMonth] + ' ' + this.currentYear;
					    }
					},
					
					updateDayDisplay() {
					    // Wochentage setzen
					    if (this.$refs.dayLabels) {
					        const dayLabels = this.$refs.dayLabels;
					        for (let i = 0; i < this.days.length && i < dayLabels.length; i++) {
					            dayLabels[i].textContent = this.days[i];
					        }
					    }
					    
					    // Tage des Monats setzen
					    if (this.$refs.dayButtons) {
					        const buttons = this.$refs.dayButtons;
					        for (let i = 0; i < this.monthDays.length && i < buttons.length; i++) {
					            const day = this.monthDays[i];
					            const btn = buttons[i];
					            
					            // Tag setzen
					            btn.textContent = day;
					            btn.dataset.day = day;
					            
					            // Styling
					            this.updateDayButtonStyle(btn, day);
					        }
					    }
					},
					
					updateDayButtonStyle(button, day) {
					    // Alle Klassen entfernen
					    button.classList.remove('bg-primary', 'text-primary-foreground', 'text-red-500');
					    
					    // Ausgewählter Tag
					    if (this.isSelected(day)) {
					        button.classList.add('bg-primary', 'text-primary-foreground');
					    }
					    // Heutiger Tag
					    else if (this.isToday(day)) {
					        button.classList.add('text-red-500');
					    }
					},

					closeDatePicker() {
						this.open = false;
					},

					updatePosition() {
    					const trigger = this.$refs.triggerButton;
						const popup = this.$refs.datePickerPopup;
						
						if (!trigger || !popup) return;
						
						const rect = trigger.getBoundingClientRect();
						const popupRect = popup.getBoundingClientRect();
						const viewportHeight = window.innerHeight;
						
						if (rect.bottom + popupRect.height > viewportHeight && rect.top > popupRect.height) {
							this.position = 'top';
						} else {
							this.position = 'bottom';
						}
					},

					calculateDays() {
						let firstDay = new Date(this.currentYear, this.currentMonth, 1).getDay();
						const daysInMonth = new Date(this.currentYear, this.currentMonth + 1, 0).getDate();
						
						firstDay = firstDay === 0 ? 6 : firstDay - 1;
						
						this.blankDays = Array.from({ length: firstDay }, (_, i) => i);
						this.monthDays = Array.from({ length: daysInMonth }, (_, i) => i + 1);
					},

					atClickPrevMonth() {
						this.currentMonth--;
						if (this.currentMonth < 0) {
							this.currentMonth = 11;
							this.currentYear--;
						}
						this.calculateDays();
						this.updateDayDisplay();
						this.updateMonthDisplay();
					},

					atClickNextMonth() {
						this.currentMonth++;
						if (this.currentMonth > 11) {
							this.currentMonth = 0;
							this.currentYear++;
						}
						this.calculateDays();
						this.updateDayDisplay();
						this.updateMonthDisplay();
					},

					parseDate(dateStr) {
						const parts = dateStr.split(/[-/.]/);
						switch(this.format) {
							case 'eu':
								return `${parts[2]}-${parts[1]}-${parts[0]}`;
							case 'us':
								return `${parts[2]}-${parts[0]}-${parts[1]}`;
							case 'uk':
								return `${parts[2]}-${parts[1]}-${parts[0]}`;
							case 'long':
							case 'iso':
							default:
								return dateStr;
						}
					},

					formatDate(date) {
						const d = date.getDate().toString().padStart(2, '0');
						const m = (date.getMonth() + 1).toString().padStart(2, '0');
						const y = date.getFullYear();

						switch(this.format) {
							case 'eu':
								return `${d}.${m}.${y}`;
							case 'uk':
								return `${d}/${m}/${y}`;
							case 'us':
								return `${m}/${d}/${y}`;
							case 'long':
								// Use the months array from the provided locale
								return `${this.months[date.getMonth()]} ${d}, ${y}`;
							case 'iso':
							default:
								return `${y}-${m}-${d}`;
						}
					},

					isToday(day) {
						const today = new Date();
						const date = new Date(this.currentYear, this.currentMonth, day);
						return date.toDateString() === today.toDateString();
					},

					isSelected(day) {
						if (!this.value) return false;
						
						try {
							const date = new Date(this.currentYear, this.currentMonth, day);
							const selected = new Date(this.parseDate(this.value));
							return date.toDateString() === selected.toDateString();
						} catch(e) {
							return false;
						}
					},

					selectDate(e) {
						const day = e.target.dataset.day;
						if (!day) return;
						
						const date = new Date(this.currentYear, this.currentMonth, day);
						this.value = this.formatDate(date);
						
						// Hidden Input aktualisieren
						this.$refs.hiddenInput.value = this.value;
						this.$refs.hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
						
						// Display-Text aktualisieren
						this.$refs.displayText.innerHTML = this.value;
						this.$refs.displayText.classList.remove('text-muted-foreground');
						
						// Tagesbuttons aktualisieren
						this.updateDayDisplay();
						
						// DatePicker schließen
						this.open = false;
					},

					positionClass() {
						return this.position === 'bottom' ? 'top-full mt-1' : 'bottom-full mb-1';
					}
				}));
			});
		</script>
	}
}
