package components

import "github.com/axzilla/templui/utils"

type LabelProps struct {
	ID            string
	Class         string
	Attributes    templ.Attributes
	For           string
	Error         string
	DisabledClass string
}

templ Label(props ...LabelProps) {
	{{ var p LabelProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<label
		if p.ID != "" {
			id={ p.ID }
		}
		if p.For != "" {
			for={ p.For }
		}
		class={
			utils.TwMerge(
				"text-sm font-medium leading-none inline-block",
				utils.If(len(p.Error) > 0, "text-destructive"),
				p.Class,
			),
		}
		if p.DisabledClass != "" {
			data-disabled-style={ p.DisabledClass }
		} else {
			data-disabled-style="opacity-50 cursor-not-allowed"
		}
		{ p.Attributes... }
	>
		{ children... }
	</label>
}

templ LabelScript() {
	{{ handle := templ.NewOnceHandle() }}
	@handle.Once() {
		<script defer nonce={ templ.GetNonce(ctx) }>
			// Inside LabelScript
			document.addEventListener('DOMContentLoaded', function() {
			  // Label click handler - automatically works for standard inputs
			  // For buttons, we only need to add a click handler
			  document.querySelectorAll('label[for]').forEach(function(label) {
				label.addEventListener('click', function(e) {
				  // Get the for-ID at the time of the click, not during initialization
				  const forId = this.getAttribute('for');
				  
				  // Find the target element with the corresponding ID
				  const targetElement = document.getElementById(forId);
				  
				  // If the target element is a button, process the click
				  if (targetElement && targetElement.tagName === 'BUTTON') {
					// Prevent the default label behavior
					e.preventDefault();
					
					// Stop event propagation to avoid duplicate clicks
					e.stopPropagation();
					
					if (!targetElement.disabled) {
					  // Ensure the button receives focus
					  targetElement.focus();
					  
					  // Slightly delay the click to avoid event conflicts
					  setTimeout(function() {
						// Create a new click event for the button
						const clickEvent = new MouseEvent('click', {
						  bubbles: true,
						  cancelable: true,
						  view: window
						});
						
						// Dispatch the click event on the button
						targetElement.dispatchEvent(clickEvent);
					  }, 10);
					}
				  }
				});
				
				// Disabled style handler
				function updateLabelStyle(label) {
				  const forId = label.getAttribute('for');
				  const targetElement = document.getElementById(forId);
				  
				  if (targetElement && targetElement.disabled) {
					// Retrieve the custom disabled style or use the default
					const disabledStyle = label.getAttribute('data-disabled-style') || 'opacity-50 cursor-not-allowed';
					disabledStyle.split(' ').forEach(function(className) {
					  if (className) {
						label.classList.add(className);
					  }
					});
				  } else {
					// Remove the disabled style
					const disabledStyle = label.getAttribute('data-disabled-style') || 'opacity-50 cursor-not-allowed';
					disabledStyle.split(' ').forEach(function(className) {
					  if (className) {
						label.classList.remove(className);
					  }
					});
				  }
				}
				
				// Update the initial style
				updateLabelStyle(label);
				
				// Create a MutationObserver for this specific label
				const forId = label.getAttribute('for');
				const targetElement = document.getElementById(forId);
				
				if (targetElement) {
				  const observer = new MutationObserver(function() {
					updateLabelStyle(label);
				  });
				  
				  observer.observe(targetElement, { 
					attributes: true, 
					attributeFilter: ['disabled'] 
				  });
				}
			  });
			});
		</script>
	}
}
